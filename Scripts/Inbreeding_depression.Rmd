---
title: "Genomics of Inbreeding in recently bottlenecked Seychelles warblers"
author: "Kiran Gok Lune Lee"
date: "`r Sys.Date()`"
geometry: margin=2cm 
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
    fig_width: 12
    fig_height: 10
    output_file: "Kiran_Lee_Genomics_Inbreeding_Seychelles_warblers.html"
  pdf_document:
    latex_engine: xelatex
    fig_width: 8
    fig_height: 6
    output_file: "Kiran_Lee_Genomics_Inbreeding_Seychelles_warblers.pdf"
---

## Set up environment

```{r setup, include=FALSE}
library(knitr)
knitr::opts_knit$set(root.dir = "~/Documents/GitHub/InProgressGenomicsInbreedingSeychellesWarblers/Data")
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	tidy = TRUE,
	tidy.opts = list(width.cutoff = 60)
)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

R.Version()
library(readr)
library(tidyverse)
library(dplyr)
library(readxl)
library(openxlsx)
library(ggplot2)
library("data.table") 
library("reshape2")
library(sequoia)
library(lmerTest)

```

# Create a massive dataframe

## SeqIDs (1st round of imputation)

Load SeqIDs of sequenced samples after first round of imputation by STITCH.

```{r seqids1, eval = TRUE, echo = FALSE, include=TRUE}
CoverageExtraSamples <- read.delim("coveragefilenameallsortedextrasamples.txt",sep=" ",header=F)
names(CoverageExtraSamples)[names(CoverageExtraSamples) == 'V1'] <- 'SeqID'
names(CoverageExtraSamples)[names(CoverageExtraSamples) == 'V2'] <- 'Coverage'
CoverageExtraSamples$Filepath<-CoverageExtraSamples$SeqID
CoverageExtraSamples$Filepath <- gsub("^.{0,4}", "", CoverageExtraSamples$Filepath)
CoverageExtraSamples$SeqID<-sub('.', '', CoverageExtraSamples$SeqID)
CoverageExtraSamples<-CoverageExtraSamples %>% separate(SeqID, c('Filepath1', 'Filepath2', 'Filepath3', 'Filepath4','Plate','Filepath5','SeqID'), sep = '/', convert = TRUE)
CoverageExtraSamples = subset(CoverageExtraSamples, select = c(Plate, SeqID, Coverage, Filepath))
CoverageExtraSamples$ID<-CoverageExtraSamples$SeqID

```

## BirdIDs

Linking SeqIDs to BirdIDs as in field database

```{r birdids, eval= TRUE, warning=FALSE, include=TRUE}
##Files to match BirdIDs
Identifiers<-read_excel("SheffieldSubmissions.xlsx")
Identifiers26076<-read_excel("ID 26076_Sample information table.xlsx")
PilotIdentifiers<-read_excel("SamplesForPilotTargetCapture_290119_sortBTN_Qubit.xlsx")
LIMS26629renamed<-read.table("lims26629renamed.txt",sep=" ",header=F)
LIMS26757p1raw4<-read.csv("Samples for Sequencing 25072023.csv",colClasses=c("NULL",NA,NA,NA,NA,NA))
MissingLIMS26757p1raw4 <- data.frame(BirdID=c(6572,6145,6373,5904,6144,6651), 
                                    FieldRing=c(NA,NA,NA,NA,NA,NA),
                                    BTO=c(NA,NA,NA,NA,NA,NA), 
                                    BloodID=c(8178, 5883,6287,5620,5880,7239), 
                                    BloodTubeNumber=c(NA,NA,NA,NA,NA,NA), 
                                    stringsAsFactors=FALSE)
LIMS26757p1raw4<-rbind(LIMS26757p1raw4,MissingLIMS26757p1raw4)
BloodID<-read.csv("BloodID.csv")

##Clean ID numbers
LIMS26629renamed<-LIMS26629renamed %>% arrange(V1)
LIMS26629renamed$SeqID<-CoverageExtraSamples$SeqID[CoverageExtraSamples$Plate=='LIMS26629']
LIMS26629renamed<-LIMS26629renamed %>%
  mutate(SeqID=sort(SeqID))
LIMS26629renamed$V1<-sub(".*\\-", "", LIMS26629renamed$V1)
colnames(LIMS26629renamed)[colnames(LIMS26629renamed) == 'V1'] <- 'ID'

#Fix 6 samples that were mislabeled, as identified by Rowan
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "100_ACAAGAACCT-CGATACTGAA_L002__all_mapped_rehead.bam")] <- 2544
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "101_AGAGTATGTG-AGATGGCTTC_L002__all_mapped_rehead.bam")] <- 3227
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "96_CAACCATACA-ACCGGTTATA_L002__all_mapped_rehead.bam")] <- 764
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "97_GTAGGCCGTT-GCCACTGTCT_L002__all_mapped_rehead.bam")] <- 2688
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "98_CGGATTGATC-AGTCACAACA_L002__all_mapped_rehead.bam")] <- 2493
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "99_ACTGGCAAGA-TGTTGTCCAT_L002__all_mapped_rehead.bam")] <- 2522

CoverageExtraSamples$ID[CoverageExtraSamples$Plate=="LIMS26629"]<-NA
CoverageExtraSamples <- merge(CoverageExtraSamples,LIMS26629renamed,by="SeqID", all = TRUE) %>%
  mutate(ID = coalesce(ID.x, ID.y)) %>%
  select (-c(ID.x, ID.y))



PilotSequences<-subset(CoverageExtraSamples, CoverageExtraSamples$Plate=="LIMS24675"|CoverageExtraSamples$Plate=="LIMS25133")
PilotSequences$ID<-trimws(sapply(strsplit(PilotSequences$ID, "_"), `[[`, 2))
MissingBloodIDSequences<-subset(CoverageExtraSamples, CoverageExtraSamples$Plate == "LIMS26076p4"|CoverageExtraSamples$Plate == "LIMS26076raw")
MissingBloodIDSequences$ID<-as.numeric(sapply(strsplit(MissingBloodIDSequences$ID, "_"), "[[", 1))
BloodIDSequences<-subset(CoverageExtraSamples, CoverageExtraSamples$Plate!="LIMS24675"& CoverageExtraSamples$Plate!="LIMS25133"&CoverageExtraSamples$Plate != "LIMS26076p4"&CoverageExtraSamples$Plate != "LIMS26076raw" )
BloodIDSequences$ID <- sub('_repeat','',BloodIDSequences$ID)
BloodIDSequences$ID <- sub('-repeat','',BloodIDSequences$ID)
BloodIDSequences$ID<-trimws(sapply(strsplit(BloodIDSequences$ID, "_"), `[[`, 1))
BloodIDSequences$ID<-sub('.+-(.+)', '\\1', BloodIDSequences$ID)

##Pilot sequences use Blood Tube Number, the rest use BloodID
PilotSequences$Identifier<-paste("BloodTubeNumber")
MissingBloodIDSequences$Identifier<-paste("BloodID")
BloodIDSequences$Identifier<-paste("BloodID")

##Make IDs numeric
PilotSequences$ID<-as.numeric(PilotSequences$ID)
BloodIDSequences$ID<-as.numeric(BloodIDSequences$ID)
MissingBloodIDSequences$ID<-as.numeric(MissingBloodIDSequences$ID)
Identifiers26076$Sample_number<-as.numeric(Identifiers26076$`Sample number`)
Identifiers26076$BloodID<-as.numeric(Identifiers26076$`Sample name`)

#Join BirdIDs
PilotSequences <- PilotSequences %>% 
  left_join(select(PilotIdentifiers, BirdID, BloodTubeNumber), by = c("ID" = "BloodTubeNumber"))

BloodIDSequences$BloodID<-BloodIDSequences$ID
BloodIDSequences <- BloodIDSequences %>% 
  left_join(select(Identifiers, BirdID, BloodID), by = c("ID" = "BloodID"))
names(BloodIDSequences)[names(BloodIDSequences) == 'BirdID.x'] <- 'BirdID'
BloodIDSequences<-BloodIDSequences[!duplicated(BloodIDSequences), ]

MissingBloodIDSequences <- MissingBloodIDSequences %>% 
  left_join(select(Identifiers26076, Sample_number, BloodID), by = c("ID" = "Sample_number"))
MissingBloodIDSequences <- MissingBloodIDSequences %>% 
  left_join(select(Identifiers, BirdID, BloodID), by = c("BloodID" = "BloodID"))

##Concatenate into one file (2018 individuals including duplicates)
MissingBloodIDSequencesFormatted= subset(MissingBloodIDSequences, select = c(Plate, SeqID, Coverage, Filepath, BloodID, Identifier, BirdID))
colnames(MissingBloodIDSequencesFormatted)[colnames(MissingBloodIDSequencesFormatted) == 'BloodID'] <- 'ID'
BloodIDSequencesFormatted= subset(BloodIDSequences, select = c(Plate, SeqID, Coverage, Filepath, ID, Identifier, BirdID))
SequencedIndividualsBirdIDs=rbind(PilotSequences,MissingBloodIDSequencesFormatted,BloodIDSequencesFormatted)

##Add in missing BirdIDs from LIMS26757p1raw4
SequencedIndividualsBirdIDsExtra<- SequencedIndividualsBirdIDs %>% 
  left_join(select(LIMS26757p1raw4, BirdID, BloodID), by = c("ID" = "BloodID")) %>%
  mutate(BirdID = coalesce(BirdID.x, BirdID.y)) %>%
  select (-c(BirdID.x, BirdID.y))

SequencedIndividualsBirdIDsExtraDeduplicated<- SequencedIndividualsBirdIDsExtra %>% 
  group_by(BirdID) %>%
  top_n(1, abs(Coverage))
```

## Test panel

This script helped me find plates and well positions for cherry-picking samples at Liverpool to re-sequence. Samples were chosen following commands in the 9choosereferencepanel.sh bash script picking the best 250 coverage that were unrelated to at least a 2nd degree.

```{r testpanel, eval=TRUE, warning=FALSE }
##Choose samples to resequence
BestCoverageUnrelated<-read.table("unrelatedimputedchromosomes250sampled2nddegree.king.cutoff.in.id")
BestCoverageUnrelated$SeqID<-basename(BestCoverageUnrelated$V2)
BestCoverageUnrelatedSampleID<- merge(BestCoverageUnrelated, SequencedIndividualsBirdIDsExtraDeduplicated, by="SeqID", all = FALSE)
BestCoverageUnrelatedToResequence<-BestCoverageUnrelatedSampleID %>%
  select(SeqID, Plate, ID, Identifier, BirdID, Coverage )
###Add in plate and well numbers to help find libraries
BestCoverageUnrelatedToResequenceWellID<- merge(BestCoverageUnrelatedToResequence, Identifiers, by="BirdID", all = FALSE)
Identifiers26076<- Identifiers26076 %>% 
  left_join(select(BloodIDSequences, BloodID, BirdID) , by = c("BloodID" = "BloodID"))
BestCoverageUnrelatedToResequenceWellIDPlate <- merge(BestCoverageUnrelatedToResequenceWellID, Identifiers26076, by= "BirdID", all= TRUE)
BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate, !is.na(BestCoverageUnrelatedToResequenceWellIDPlate$SeqID))
BestCoverageUnrelatedToResequenceWellIDPlate <- BestCoverageUnrelatedToResequenceWellIDPlate[-c(18, 20, 21), ]

BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate,BestCoverageUnrelatedToResequenceWellIDPlate$Identifier=="BloodID")

BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate,BestCoverageUnrelatedToResequenceWellIDPlate$Plate.x!="LIMS24675")
BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate,BestCoverageUnrelatedToResequenceWellIDPlate$Plate.x!="LIMS25133")

openxlsx::write.xlsx(BestCoverageUnrelatedToResequenceWellIDPlate, file ="BestCoverageUnrelatedToResequenceWellIDPlate.xlsx", quote=FALSE)
getwd()

```

This script creates a set of UNIX commands to merge re-sequenced samples creating a higher coverage test set to assess imputation accuracy. Re-sequenced samples were verified as duplicateds using PLINK.

```{r warning=FALSE, include=FALSE}
##Merge reference panel
SequencedIndividualsBirdIDsExtraDeduplicated<- SequencedIndividualsBirdIDsExtra %>% 
  group_by(BirdID) %>%
  top_n(1, abs(Coverage))
###These samples have been checked they are indeed duplicates using PLINK
ReferencePanel<- read.delim("duplicatereferencepairs0.3na1.kin0",sep=" ",header=T,col.names=c("","Resequence","","SeqID","","","",""),row.names=NULL)
ReferencePanel<- subset(ReferencePanel, select = -c(X,X.1,X.2,X.3,X.4,X.5) )
ReferencePanel[] <- lapply(ReferencePanel, gsub, pattern='./Clean_aligned/', replacement='')

#Add in filepaths
ReferencePanel<-merge(ReferencePanel, SequencedIndividualsBirdIDsExtraDeduplicated , by="SeqID") %>%
                        select(Resequence,Filepath) 
ReferencePanel$Merged_output<-ReferencePanel$Filepath
ReferencePanel$Resequence <- sub("^", "/fastdata/bop21kgl/RawData/LIMS202103/Clean_aligned/", ReferencePanel$Resequence )
ReferencePanel$Merged_output<-gsub(".*/","",ReferencePanel$Merged_output)
ReferencePanel$Merged_output <- sub("^", "/fastdata/bop21kgl/RawData/LIMSMERGED/Clean_aligned/", ReferencePanel$Merged_output )
ReferencePanel$Command= "samtools merge"
ReferencePanel<-ReferencePanel[,c(4,3,1,2)]

#Write out commands for samtools to merge files
write.table(ReferencePanel, file = "ReferencePanel.txt", sep = " ",
            col.names = F, row.names = F, quote = FALSE)

openxlsx::write.xlsx(ReferencePanel, file ="ReferencePanel.xlsx", quote=FALSE)

```

## SeqIDs (2nd round of imputation with "test" panel)

```{r seqids2, eval=TRUE, echo=FALSE}

TestPanelSamples<- read.delim("coveragefilenameallsortedextrasamplesimputed.txt",sep=" ",header=F)
names(TestPanelSamples)[names(TestPanelSamples) == 'V1'] <- 'SeqID'
names(TestPanelSamples)[names(TestPanelSamples) == 'V2'] <- 'Coverage'
TestPanelSamples$Filepath<-TestPanelSamples$SeqID
TestPanelSamples$Filepath <- gsub("^.{0,4}", "", TestPanelSamples$Filepath)
TestPanelSamples$SeqID<-sub('.', '', TestPanelSamples$SeqID)
TestPanelSamples<-TestPanelSamples %>% separate(SeqID, c('Filepath1', 'Filepath2', 'Filepath3', 'Filepath4','Plate','Filepath5','SeqID'), sep = '/', convert = TRUE)
TestPanelSamples = subset(TestPanelSamples, select = c(Plate, SeqID, Coverage, Filepath))
TestPanelSamples$ID<-TestPanelSamples$SeqID
TestPanelSamples<-subset(TestPanelSamples, TestPanelSamples$Plate=="LIMSMERGED")

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(TestPanelSamples %>% select(SeqID, Plate, Coverage, Filepath), by = "SeqID", suffix = c(".orig", ".new")) %>%
  mutate(
    Plate = coalesce(Plate.new, Plate.orig),  # Replace Plate.orig with Plate.new
    Coverage = coalesce(Coverage.new, Coverage.orig),  # Replace Coverage.orig with Coverage.new
    Filepath = coalesce(Filepath.new, Filepath.orig)  # Replace Coverage.orig with Coverage.new
  ) %>%
  select(-Plate.new, -Coverage.new, -Filepath.new)  # Remove the extra columns from the join

##Create downsample factor for samples to downsample using /SNPsSeychellesWarbler/blob/main/3_Imputation_accuracy/4downsamplecorrectcoverage.sh before imputing with STITCH
DownsampleReferencePanel<-subset(SequencedIndividualsBirdIDsExtraDeduplicated, SequencedIndividualsBirdIDsExtraDeduplicated$Plate=="LIMSMERGED")
DownsampleReferencePanel$Multiplier0.1X<-1/DownsampleReferencePanel$Coverage
DownsampleReferencePanel<-DownsampleReferencePanel %>%
  ungroup() %>%
  select(Filepath, Multiplier0.1X)

write.table(ReferencePanel, file = "downsamplescalingnew", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

```

## Genotype sex

This is important to check if we have assigned IDs correctly. If the sex of sample as calculated by imputed genotypes does not match the sex as recorded by microsatellites from the field database, something must be up.

```{r sex, eval=TRUE, echo = TRUE, tidy=FALSE}
##Load field database sex data
BirdIDSexYear <- read_excel("BirdIDSexYear.xlsx")


##Add in field database sex of bird
SequencedIndividualsBirdIDsExtraDeduplicated <- merge(SequencedIndividualsBirdIDsExtraDeduplicated, BirdIDSexYear[, c("BirdID", "Sex")], by = "BirdID", all.x = TRUE)
SequencedIndividualsBirdIDsExtraDeduplicated<-SequencedIndividualsBirdIDsExtraDeduplicated[!duplicated(SequencedIndividualsBirdIDsExtraDeduplicated),]

##Add in genotype sex of bird (heterozygosity of Z chromosome)
Zheterozygosity <- read.table("plink2.scount",header=TRUE, col.names=c("Filepath", "nHom", "nHet"))
Zheterozygosity$Het<- Zheterozygosity$nHet/(Zheterozygosity$nHom+Zheterozygosity$nHet)
Zheterozygosity$Het <- round(Zheterozygosity$Het, 5)
hist(Zheterozygosity$Het, breaks=120)

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(Zheterozygosity , by = "Filepath")

##Add in genotype sex of bird (Z:W coverage and Autosome:Z coverage)
SexChromosomeCoverage<-read.table(file = "zw_autosomew_coverageall_clean.txt",sep=" ",header=F, col.names = c("SeqID","RatioZW", "RatioAutosomesW", "RatioAutosomesZ", "Mean_autosomes_cov", "Z_cov" , "W_cov"),  fill = TRUE)
SexChromosomeCoverage$Mean_autosomes_cov<-as.numeric(SexChromosomeCoverage$Mean_autosomes_cov)
SexChromosomeCoverage$RatioZW<-as.numeric(SexChromosomeCoverage$RatioZW)
SexChromosomeCoverage$RatioAutosomesW<-as.numeric(SexChromosomeCoverage$RatioAutosomesW)
SexChromosomeCoverage$RatioAutosomesZ<-as.numeric(SexChromosomeCoverage$RatioAutosomesZ)
hist(SexChromosomeCoverage$RatioAutosomesZ, breaks=120)
SexChromosomeCoverage<- SexChromosomeCoverage %>% 
  group_by(SeqID) %>%
  top_n(1, abs(Mean_autosomes_cov))
SexChromosomeCoverage<-SexChromosomeCoverage[!duplicated(SexChromosomeCoverage),]


SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(SexChromosomeCoverage , by = "SeqID")

PlinkSexCheck<- read.table("plink.sexcheck", header = TRUE, col.names=c("Filepath", "Filepath1", "PEDSEX", "SNPSEX", "STATUS","F"))

#NB. PLINKs sex check function is redundant because it uses Z chromosome heterozygosity so can exclude. 

# Merge SequencedIndividualsBirdIDsExtraDeduplicated with PlinkSexCheck on Filepath, 
# but only keep rows where PlinkSexCheck$F is not NA or has values
SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(PlinkSexCheck %>% filter(!is.na(F)), by = "Filepath")

SequencedIndividualsBirdIDsExtraDeduplicated$Sex <- as.factor(SequencedIndividualsBirdIDsExtraDeduplicated$Sex)
SequencedIndividualsBirdIDsExtraDeduplicated$W_cov <- as.numeric(SequencedIndividualsBirdIDsExtraDeduplicated$W_cov)
SequencedIndividualsBirdIDsExtraDeduplicated$Z_cov <- as.numeric(SequencedIndividualsBirdIDsExtraDeduplicated$Z_cov)
SequencedIndividualsBirdIDsExtraDeduplicated$ProportionalZCoverage <- 
  SequencedIndividualsBirdIDsExtraDeduplicated$Z_cov / SequencedIndividualsBirdIDsExtraDeduplicated$Coverage

# Predict sex using a model
SexPrediction <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  filter(!is.na(Het) & !is.na(ProportionalZCoverage)& RatioZW > 0)

library(caret)
set.seed(123)
# Split the data into training (80%) and testing (20%) sets
trainIndex <- createDataPartition(SexPrediction$Sex, 
                                  p = 0.8, 
                                  list = FALSE)
trainData <- SexPrediction[trainIndex, ]
testData <- SexPrediction[-trainIndex, ]

# Train a logistic regression model
logisticSexModel <- glm(Sex ~ cbind(Z_cov,Coverage) + cbind(nHet,nHom), 
                     data = trainData, 
                     family = "binomial")

# View model summary
summary(logisticSexModel)

# Predict on the test data
predictions <- predict(logisticSexModel, testData, type = "response")

# Convert probabilities to class labels (0 = female, 1 = male, assuming male = 1, female = 0)
predictedClasses <- ifelse(predictions > 0.5, "male", "female")
predictedClasses <- factor(predictedClasses, levels = c("female", "male"))

levels(predictedClasses) <- levels(testData$Sex)
confusionMatrix(predictedClasses, testData$Sex)

accuracy <- sum(predictedClasses == testData$Sex) / length(testData$Sex)
print(paste("Accuracy: ", accuracy))


#Build model 
logisticSexModel <- glm(Sex ~ cbind(Z_cov,Coverage) + cbind(nHet,nHom), 
                     data = SexPrediction, 
                     family = "binomial")

#Assign sex based off model
predicted_probs <- predict(logisticSexModel, SexPrediction, type = "response")
predicted_sex <- ifelse(predicted_probs > 0.5, "1", "0")

# Add the predicted sex to the data
SexPrediction$PredictedSex <- predicted_sex

#PoorSequences<-subset(SequencedIndividualsBirdIDsExtraDeduplicated, is.na(SequencedIndividualsBirdIDsExtraDeduplicated$Het) | is.na(SequencedIndividualsBirdIDsExtraDeduplicated$ProportionalZCoverage) | SequencedIndividualsBirdIDsExtraDeduplicated$RatioZW <= 0)

#PoorSequences$PredictedSex<-PoorSequences$Sex
#SexPrediction <- rbind(SexPrediction, PoorSequences)

# Identify rows where CHD gene sex does not match the predicted sex
SexMismatches <- SexPrediction[SexPrediction$Sex != SexPrediction$PredictedSex, ]


# Load necessary libraries
library(ggplot2)
library(ggrepel)  # For better label positioning

# Create the plot with geom_text_repel to prevent label overlap
ggplot(subset(SexPrediction, SexPrediction$RatioZW>0), aes(x = ProportionalZCoverage, y = Het, color = Sex)) +
  geom_point() +  # Scatter plot of the data
  labs(x = "Z coverage", y = "Het", title = "Plot of Proportional Z chromosome Coverage by Z chromosome Heterozygosity") +
  theme_minimal() +  # Minimal theme
  scale_color_manual(values = c("red", "blue")) +  # Color for sexes
  geom_text_repel(data = SexMismatches, 
                  aes(x = ProportionalZCoverage, y = Het, label = BirdID), 
                  color = "black", 
                  size = 3,  # Adjust label size
                  box.padding = 0.5,  # Space between label and point
                  max.overlaps = 50,  # Limit the number of overlaps (e.g., 50 labels can overlap)
                  force = 2,  # Set force to avoid excessive movement of labels
                  max.iter = 1000,  # Limit number of iterations for adjusting the labels
                  segment.size = 0.5) +  # Adjust the segment size connecting the labels
  xlim(min(SexPrediction$ProportionalZCoverage) - 0, max(SexPrediction$ProportionalZCoverage) + 0) +  # Adjust plot limits
  ylim(min(SexPrediction$Het) - 0, max(SexPrediction$Het) + 0)  # Adjust plot limits



```

## Life-history traits

```{r life-history, eval=TRUE, echo=FALSE, include=TRUE}
#Lifespan ----
##Read files
BirthDate <- read_csv("BirthDate27032023.csv", col_types = cols(BirthDate = col_date(format = "%d/%m/%Y"))) #In query table, this is BirdID
LastSeenYear <- read_csv("CurrentBTOextended27032023.csv") #In query table, this is CurrentBTOextended
BirdIDSexYear <- read_excel("BirdIDSexYear.xlsx")

##Make terms
###BirthYear from BirthDate
BirthDate <- BirthDate %>% 
  mutate(BirthYear = format(BirthDate, "%Y")) %>%
  mutate(BirthYear = as.numeric(BirthYear))

###Lifespan
Lifespan <- merge(BirthDate,LastSeenYear,by="BirdID", all = TRUE) %>% 
  mutate(LastSeenYea = as.numeric(LastSeenYea)) %>%
  mutate(BirthYear = as.numeric(BirthYear)) %>%
  mutate(Lifespan = LastSeenYea - BirthYear) %>%
  filter(LastSeenYea < 2022)  %>%
  select(BirdID,Lifespan,BirthYear,LastSeenYea)
colnames(Lifespan)[colnames(Lifespan) == 'LastSeenYea'] <- 'LastSeenYear'

##Link lifespan to dataframe
SequencedIndividualsBirdIDsExtraDeduplicated<- merge(SequencedIndividualsBirdIDsExtraDeduplicated, Lifespan, by="BirdID", all = TRUE)

##Link n offspring to dataframe
Offspring <- read_csv("Offspring27032023.csv",col_types = cols(BirthDate = col_date(format = "%d/%m/%Y")))
ROcount <- Offspring %>% filter(Confidence > 80) %>% count(Parent) %>% rename(BirdID = Parent,ReproductiveOutput = n)
SequencedIndividualsBirdIDsExtraDeduplicated<- merge(SequencedIndividualsBirdIDsExtraDeduplicated, ROcount, by="BirdID", all = TRUE)

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  filter(!is.na(SeqID))


```

## Pedigree

Pedigree construction by *sequoia.* 572 SNPs were chosen after filtering for minor allele frequency \> 0.3, genotyping rate \> 99.9 and for linkage and also excluding SNPs on sex chromosomes and on chromosomes with \<90% imputation accuracy. Parentge assignment comparison suggests masterbayes is at least 94% accurate so is useful for verifying sample identities where there are mixups.

```{r pedigree, eval = TRUE, echo = TRUE, tidy=FALSE}
#Deduplicate samples for sequioa as it doesn't handle duplicates
DeduplicatedforSequoia<-data.frame(rep("0",length(SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)),SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)
write.table(DeduplicatedforSequoia, file = "DeduplicatedforSequoia.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Rename samples for sequioa to BirdIDs
RenameforSequoia<-data.frame(rep("0",length(SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)),SequencedIndividualsBirdIDsExtraDeduplicated$Filepath,rep("0",length(SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)),SequencedIndividualsBirdIDsExtraDeduplicated$BirdID)
write.table(RenameforSequoia, file = "RenameforSequoia.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Read in SNPs in .raw format
sw_GenoM_family <- GenoConvert(InFile = "reimputedinputfile_for_sequoia.raw", InFormat="raw")

#Read in pedigree from masterbayes
masterped <- read.csv("pedFINAL_var124567_combined_unique_20230413.csv")
head(masterped)
names(masterped)[names(masterped) == 'dad'] <- 'sire'
names(masterped)[names(masterped) == 'mum'] <- 'dam'

#drop unnecessary column
masterped <- masterped[-c(4)]

#Read in life history data
sw_LifeHistData <- read.csv("LifeHistoryData.csv", header = TRUE)
sw_LifeHistData<-sw_LifeHistData[!duplicated(sw_LifeHistData),]
sw_LifeHistData$Sex <- case_when(sw_LifeHistData$Sex == "0" ~ 1, 
                                 sw_LifeHistData$Sex == "1" ~ 2, 
                                 TRUE ~ 3)

#drop birds born before 1991 as they are not sampled
sw_LifeHistData <- sw_LifeHistData[sw_LifeHistData$Year > 1990,]

#drop birds not in cousin
sw_LifeHistData <- sw_LifeHistData[sw_LifeHistData$Island == "CN",]

#drop unnecessary column
sw_LifeHistData <- sw_LifeHistData[,-2]
sw_LifeHistData <- sw_LifeHistData[,-3]

sw_LifeHistData<-na.omit(sw_LifeHistData)

#Looks like lots of duplicate BirdIDs so create new life hist file
BirthDate <- read_csv("BirthDate27032023.csv", col_types = cols(BirthDate = col_date(format = "%d/%m/%Y"))) #In query table, this is BirdID
BirdIDSexYear <- read_excel("BirdIDSexYear.xlsx")
lifehist<- merge(BirthDate, BirdIDSexYear, by= "BirdID", all= TRUE)%>%
  select(BirdID,Sex,BirthDate)
lifehist<-lifehist[!duplicated(lifehist),]
lifehist$Sex <- case_when(lifehist$Sex == "0" ~ 1, 
                          lifehist$Sex == "1" ~ 2, 
                                 TRUE ~ 3)
lifehist$BirthDate<-format(as.Date(lifehist$BirthDate, format="%Y/%m/%d"),"%Y")
colnames(lifehist)[colnames(lifehist) == 'BirthDate'] <- 'Year'
lifehist<-lifehist[-c(1, 2), ]  

# 1. Initial diagnostics --------------------------------------------------

# Check genotype calls across the dataset (-9 = missing calls)
summary.factor(as.factor(sw_GenoM_family))/(nrow(sw_GenoM_family)*ncol(sw_GenoM_family))

# Check for Mendelian errors in the data at the locus level
GenoM_checks <- SnpStats(sw_GenoM_family, Ped = masterped[,c("id", "dam", "sire")])

ggplot(GenoM_checks, aes(x = OHdam)) + geom_histogram() + theme_classic()
ggplot(GenoM_checks, aes(x = OHsire)) + geom_histogram() + theme_classic()
sw_OHLLR_DATABASE <- CalcOHLLR(Pedigree = masterped[,c("id", "dam", "sire")], GenoM = sw_GenoM_family)
ggplot(sw_OHLLR_DATABASE, aes(y = LLRdam, x = OHdam)) + geom_point(alpha = 0.6) + theme_classic()
ggplot(sw_OHLLR_DATABASE, aes(y = LLRsire, x = OHsire)) + geom_point(alpha = 0.6) + theme_classic()
SummarySeq(sw_OHLLR_DATABASE, Panels = "OH")

# 2. Run basic sequoia ------------------------------------

# Note modules used to build up from basic input check to analysis:
# i.   'pre': Input check
# ii.  'dup': check for duplicates
# iii. 'par': parentage assignment
# iv.  'ped': full pedigree reconstruction

# Just parentage assignment (Module = "par"). 
sw_family_sequoia_justparents <- sequoia(GenoM = sw_GenoM_family, LifeHistData = lifehist, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

# A 94.0% match to the masterbayes pedigree
sw_family_pedigree_justparents_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents$Pedigree, Plot=TRUE, Symmetrical = TRUE)

SummarySeq(SeqList = sw_family_sequoia_justparents)


# Full pedigree reconstruction (Module = "ped"). Hashed out of knit because takes too long.
#sw_family_sequoia <- sequoia(GenoM = sw_GenoM_family, LifeHistData = lifehist, Module = "ped", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))
#sw_family_pedigree_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia$Pedigree, Plot=TRUE)$MergedPed

```

## ROH

Include FROH as calculated by PLINK

```{r roh, eval=TRUE, warning=FALSE, include=TRUE }
##Large ROH (ROH>3.75Mb)
MySequencedIndividualsLargeROH<-read_table("largeROHnew.hom.indiv")
MySequencedIndividualsLargeROH$IID<-sub('.', '', MySequencedIndividualsLargeROH$IID)
MySequencedIndividualsLargeROH<-MySequencedIndividualsLargeROH %>% separate(IID, c('Filepath1', 'Filepath2', 'Filepath3', 'Plate','Filepath4','SeqID'), sep = '/', convert = TRUE)
MySequencedIndividualsLargeROH = subset(MySequencedIndividualsLargeROH, select = c(Plate, SeqID, NSEG, KB, KBAVG))
MySequencedIndividualsLargeROH$ID<-MySequencedIndividualsLargeROH$SeqID
MySequencedIndividualsLargeROH$FROH<-MySequencedIndividualsLargeROH$KB/1091184475*1000
names(MySequencedIndividualsLargeROH)[names(MySequencedIndividualsLargeROH) == 'FROH'] <- 'LargeFROH'

##Medium ROH (ROH>1.36Mb)
MySequencedIndividualsMediumROH<-read_table("mediumROHnew.hom.indiv")
MySequencedIndividualsMediumROH$IID<-sub('.', '', MySequencedIndividualsMediumROH$IID)
MySequencedIndividualsMediumROH<-MySequencedIndividualsMediumROH %>% separate(IID, c('Filepath1', 'Filepath2', 'Filepath3', 'Plate','Filepath4','SeqID'), sep = '/', convert = TRUE)
MySequencedIndividualsMediumROH = subset(MySequencedIndividualsMediumROH, select = c(Plate, SeqID, NSEG, KB, KBAVG))
MySequencedIndividualsMediumROH$ID<-MySequencedIndividualsMediumROH$SeqID
MySequencedIndividualsMediumROH$FROH<-MySequencedIndividualsMediumROH$KB/1091184475*1000
names(MySequencedIndividualsMediumROH)[names(MySequencedIndividualsMediumROH) == 'FROH'] <- 'MediumFROH'

##Small ROH (ROH>0.375Mb)
MySequencedIndividualsSmallROH<-read_table("smallROHnew.hom.indiv")
MySequencedIndividualsSmallROH$IID<-sub('.', '', MySequencedIndividualsSmallROH$IID)
MySequencedIndividualsSmallROH<-MySequencedIndividualsSmallROH %>% separate(IID, c('Filepath1', 'Filepath2', 'Filepath3', 'Plate','Filepath4','SeqID'), sep = '/', convert = TRUE)
MySequencedIndividualsSmallROH = subset(MySequencedIndividualsSmallROH, select = c(Plate, SeqID, NSEG, KB, KBAVG))
MySequencedIndividualsSmallROH$ID<-MySequencedIndividualsSmallROH$SeqID
MySequencedIndividualsSmallROH$FROH<-MySequencedIndividualsSmallROH$KB/1091184475*1000
names(MySequencedIndividualsSmallROH)[names(MySequencedIndividualsSmallROH) == 'FROH'] <- 'SmallFROH'

# Perform the joins
ROH <- MySequencedIndividualsLargeROH
ROH$MediumFROH<-MySequencedIndividualsMediumROH$MediumFROH
ROH$SmallFROH<-MySequencedIndividualsSmallROH$SmallFROH
ROH$LargeFROHbin<-ROH$LargeFROH
ROH$MediumFROHbin<-ROH$MediumFROH-(ROH$LargeFROH)
ROH$SmallFROHbin<-ROH$SmallFROH-(ROH$MediumFROH)

ROH <- ROH %>%
  arrange(SeqID, desc(Plate == "LIMSMERGED")) %>%
  distinct(SeqID, .keep_all = TRUE)

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(ROH %>% select(SeqID, LargeFROHbin, MediumFROHbin, SmallFROHbin), by = "SeqID")

ggplot(SequencedIndividualsBirdIDsExtraDeduplicated, aes(x = Coverage, y = LargeFROHbin)) +
  geom_point() +  # Scatter plot for the data points
  geom_smooth(method = "lm", color = "blue", se = FALSE) +
  labs(title = "Coverage vs LargeFROHbin", 
       x = "Coverage", 
       y = "LargeFROHbin") +
  theme_minimal()


```

Call ROH using RZooRoH.

```{r eval=FALSE, echo=FALSE, include==FALSE}
#install.packages("RZooRoH", repos = "http://cran.us.r-project.org")
#Check out the package
library(RZooRoH)
## load data
SNPs <- zoodata(genofile = "rzoorohGP.gen", zformat = "gp")
## define model (e.g. if you simply want to capture all segments, you can put 4 classes 10, 100, 1000 + non-HBD)
mix4R <- zoomodel(K=4, base=10, err = 0.0025, layers=TRUE)
## run model on data
SNPsmodel <- zoorun(mix4R, SNPs, localhbd = TRUE)

```
##Sample mismatches

Investigating mismatches between field database and genotype data. Maria-elena had some DNA extracted in plates for telomere work. This is where "plate 53" comes from. Hannah then cherry-picked samples from these plates.

```{r sample_mismatch, eval=TRUE, echo=TRUE, include=TRUE}
library(dplyr)
# First let's deal with sex mismatches. Recall the mismatches outputted from the model
view(SexMismatches)

PedigreeMismatch<-sw_family_pedigree_justparents_comparison[["Mismatch"]]
TestPedigreeMismatch<-sw_family_pedigree_justparents_comparison[["MergedPed"]]
TestPedigreeMismatchSubset <- TestPedigreeMismatch %>%
  filter(!(dam.class == "Match" | sire.class == "Match"))


SexMismatches$BirdID <- as.character(SexMismatches$BirdID)
PedigreeMismatch$id <- as.character(PedigreeMismatch$id)
TestPedigreeMismatchSubset$id <- as.character(TestPedigreeMismatchSubset$id)

SexMismatches$PedigreeMismatch <- apply(SexMismatches, 1, function(row) {
  any(row["BirdID"] %in% unlist(PedigreeMismatch))
})
# Assuming PedigreeMismatch is a dataframe with an 'id' column
SexMismatches$PedigreeMismatch <- apply(SexMismatches, 1, function(row) {
  any(row["BirdID"] %in% PedigreeMismatch$id)
})

#For BirdID: 1668, SeqID: 98-1015_221007_L003__all_mapped_rehead.bam, the bird was only seen twice in 2002 (Unknown) and 2003 (SEEN1). Field database is marked as male by molecular sexing but female by observation. INCLUDE AS F?


##Genomic relatedness comparison to masterbayes pedigree relatedness

#Convert masterbayes pedigree to relatedness

Rped.old<-CalcRped(masterped, OUT="DF")
Rel.snp<- read.table("plink2.grm", stringsAsFactors = FALSE)
Rel.id <- read.table("plink2.grm.id", stringsAsFactors=FALSE)
Rel.id<-merge(Rel.id, RenameforSequoia, by.x='V2', by.y='SequencedIndividualsBirdIDsExtraDeduplicated.Filepath') %>% select(V1,SequencedIndividualsBirdIDsExtraDeduplicated.BirdID)
Rel.snp[,1] <- as.character(factor(Rel.snp[,1], labels=Rel.id[,2]))
Rel.snp[,2] <- as.character(factor(Rel.snp[,2], labels=Rel.id[,2]))
names(Rel.snp) <- c("IID1", "IID2", "nSNPS", "R.GRM")
Rel.snp <- Rel.snp[Rel.snp$IID1 != Rel.snp$IID2,] 
Rel.both <- merge(data.table(Rel.snp[,c(1,2,4)], key=c("IID1", "IID2")),
                  data.table(Rped.old, key=c("IID1", "IID2")), all.x=TRUE)
rm(Rel.snp, Rped.old)   # clean up: remove large dataframes
round(cor(Rel.both[, c("R.GRM","R.ped")],use="pairwise.complete"), 3)
hexbin::hexbinplot(Rel.both$R.GRM ~ Rel.both$R.ped,
                   xbins=100, aspect=1, 
                   xlim=c(0.05,1), ylim=c(-.7, 2.8),
                   xlab="Pedigree relatedness", ylab="Genomic relatedness",
                   trans=log10, inv=function(x) 10^x,
                   colorcut=seq(0,1,length=14), maxcnt=10^6.5,
                   colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')})

hb <- hexbin::hexbin(Rel.both$R.GRM ~ Rel.both$R.ped,
                     xbins=100, xbnds=c(-.05, 2), ybnds=c(-.7, 2.8),
                     xlab="Pedigree relatedness", ylab="Genomic relatedness")
hbp <- hexbin::plot(hb,
                                  trans=log10, inv=function(x) 10^x,
                                  colorcut=seq(0,1,length=14), maxcnt=10^6.5,
                                  colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')}
                                  )
hexbin::hexVP.abline(hbp$plot.vp, lm(Rel.both$R.GRM ~ Rel.both$R.ped))

#We can try find which bird it is we incorrectly sampled for sequencing.
##Change sex of samples to "unknown" in sequoia and re-run parentage assignment. Then see which bird is it's parents and offspring and compare to microsat pedigree.
lifehistsexunknown<-lifehist
lifehistsexunknown$Sex[lifehistsexunknown$BirdID %in% SexMismatches$BirdID] <- 3

# Just parentage assignment (Module = "par"). 
sw_family_sequoia_justparents <- sequoia(GenoM = sw_GenoM_family, LifeHistData = lifehistsexunknown, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

sw_family_pedigree_justparents_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents$Pedigree, Plot=TRUE, Symmetrical = TRUE)

#Any duplicate samples  in sequoia input SNPs? Yes, 29.
DuplicatesSequoia<-sw_family_sequoia_justparents[["DupGenotype"]]

# Verify these from PLINK, calling duplicates by --king-table-filter 0.35 for 487,107 SNPs (genotyping rate > 99.9 and MAF > 0.3)
UnintentionalDuplicates<- read.table("unintentionalduplicates.kin0", stringsAsFactors = FALSE)
PLINKDuplicates<- read.table("unintentionalduplicates.kin0", stringsAsFactors = FALSE)
# Loop through rows of UnintentionalDuplicates and add BirdID from SequencedIndividualsBirdIDsExtraDeduplicated to V1 where V2 matches Filepath
# Loop through rows of UnintentionalDuplicates and add BirdID from SequencedIndividualsBirdIDsExtraDeduplicated to V1 where V2 matches Filepath
#Add BirdIDs
UnintentionalDuplicates$V1[UnintentionalDuplicates$V2 %in% SequencedIndividualsBirdIDsExtraDeduplicated$Filepath] <- 
  SequencedIndividualsBirdIDsExtraDeduplicated$BirdID[match(UnintentionalDuplicates$V2, SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)]

UnintentionalDuplicates$V3[UnintentionalDuplicates$V4 %in% SequencedIndividualsBirdIDsExtraDeduplicated$Filepath] <- 
  SequencedIndividualsBirdIDsExtraDeduplicated$BirdID[match(UnintentionalDuplicates$V4, SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)]

# Rename columns in UnintentionalDuplicates
colnames(UnintentionalDuplicates) <- c("BirdID1", "Filepath1", "BirdID2", "Filepath2", "NSNPs", "V6", "V7", "Kinship")

# Subset UnintentionalDuplicates to remove rows where Kinship is NA
UnintentionalDuplicates <- UnintentionalDuplicates[!is.na(UnintentionalDuplicates$Kinship), ]

# Initialize the new column with FALSE (or NA) in UnintentionalDuplicates
UnintentionalDuplicates$SexMismatchedDuplicate <- FALSE

# Loop through each BirdID in SexMismatches to check if it matches in either BirdID1 or BirdID2 in UnintentionalDuplicates
for (i in 1:nrow(SexMismatches)) {
  matching_rows <- UnintentionalDuplicates[UnintentionalDuplicates$BirdID1 == SexMismatches$BirdID[i] |
                                           UnintentionalDuplicates$BirdID2 == SexMismatches$BirdID[i], ]
  
  if (nrow(matching_rows) > 0) {
    UnintentionalDuplicates$SexMismatchedDuplicate[UnintentionalDuplicates$BirdID1 == SexMismatches$BirdID[i] |
                                                  UnintentionalDuplicates$BirdID2 == SexMismatches$BirdID[i]] <- TRUE
  }
}


# Create a new column in SexMismatches to store the Kinship values
SexMismatches$Kinship <- NA  # Initialize with NA

# Loop through each BirdID in SexMismatched to check if it matches in either BirdID1 or BirdID2 in UnintentionalDuplicates
for (i in 1:nrow(SexMismatches)) {
  matched_row <- UnintentionalDuplicates[UnintentionalDuplicates$BirdID1 == SexMismatches$BirdID[i] |
                                        UnintentionalDuplicates$BirdID2 == SexMismatches$BirdID[i], ]
  
  if (nrow(matched_row) > 0) {
    SexMismatches$Kinship[i] <- matched_row$Kinship[1] 
  }
}


# Initialize the new column in UnintentionalDuplicates with FALSE (or NA)
UnintentionalDuplicates$SequoiaDuplicate <- FALSE

UnintentionalDuplicates$BirdID1 <- as.character(UnintentionalDuplicates$BirdID1)
UnintentionalDuplicates$BirdID2 <- as.character(UnintentionalDuplicates$BirdID2)
DuplicatesSequoia$ID1 <- as.character(DuplicatesSequoia$ID1)
DuplicatesSequoia$ID2 <- as.character(DuplicatesSequoia$ID2)

# Perform a left join to merge UnintentionalDuplicates with relevant columns from DuplicatesSequoia
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(DuplicatesSequoia %>%
              select(ID1, ID2, Mismatch, SnpdBoth, LLR), 
            by = c("BirdID1" = "ID2", "BirdID2" = "ID1")) %>%
  mutate(SequoiaDuplicate = ifelse(BirdID1 %in% DuplicatesSequoia$ID1 | 
                                     BirdID1 %in% DuplicatesSequoia$ID2 |
                                     BirdID2 %in% DuplicatesSequoia$ID1 | 
                                     BirdID2 %in% DuplicatesSequoia$ID2, 
                                   TRUE, FALSE))


#Subset for PLINK Kinship > 0.496 as there are no duplicates over this value 
UnintentionalDuplicates <- subset(UnintentionalDuplicates,UnintentionalDuplicates$Kinship > 0.496)

#There are 29 duplicates as found by sequoia and confirmed with PLINK. Now we need to investigate which is the correct BirdID out of two. 
#11 duplicate pairs can be confirmed using sex
#329 is in fact 1176
#478 is in fact 3444
#4882 is in fact 3643
#4883 is in fact 1607
#5542 is in fact 6136
#5546 is in fact 6175
#5550 is in fact 4961
#5585 is in fact 4943
#6150 is in fact 5786
#6862 is in fact 6670
#1276 is in fact 1765

#15 can be confirmed by comparing with masterbayes mother
# Perform a left join to look up the mother (dam) from masterped using id
UnintentionalDuplicates$BirdID1 <- as.character(UnintentionalDuplicates$BirdID1)
UnintentionalDuplicates$BirdID2 <- as.character(UnintentionalDuplicates$BirdID2)
Rel.both$IID1<-as.character(Rel.both$IID1)
Rel.both$IID2<-as.character(Rel.both$IID2)

masterped$id <- as.character(masterped$id)

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(masterped %>%
              select(id, dam), 
            by = c("BirdID1" = "id")) %>%
  rename(BirdID1Mum = dam)

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(masterped %>%
              select(id, dam), 
            by = c("BirdID2" = "id")) %>%
  rename(BirdID2Mum = dam)

UnintentionalDuplicates$BirdID1Mum <- as.character(UnintentionalDuplicates$BirdID1Mum)
UnintentionalDuplicates$BirdID2Mum <- as.character(UnintentionalDuplicates$BirdID2Mum)

# Step 1: Perform the joins for BirdID1 and BirdID1Mum
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_1 = R.GRM), 
            by = c("BirdID1" = "IID1", "BirdID1Mum" = "IID2")) %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_2 = R.GRM), 
            by = c("BirdID1" = "IID2", "BirdID1Mum" = "IID1")) %>%
  mutate(BirdID1MumRel = coalesce(R.GRM_1, R.GRM_2))

# Step 2: Perform the joins for BirdID2 and BirdID2Mum
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_3 = R.GRM), 
            by = c("BirdID2" = "IID1", "BirdID2Mum" = "IID2")) %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_4 = R.GRM), 
            by = c("BirdID2" = "IID2", "BirdID2Mum" = "IID1")) %>%
  mutate(BirdID2MumRel = coalesce(R.GRM_3, R.GRM_4))

PedigreeComparison<-sw_family_pedigree_justparents_comparison[["MergedPed"]]

# Join for BirdID1 and create BirdID1MumMatch
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(PedigreeComparison %>% select(id, dam.class), 
            by = c("BirdID1" = "id")) %>%
  mutate(BirdID1MumMatch = dam.class) %>%
  select(-dam.class)  # Remove dam.class column if not needed

# Join for BirdID2 and create BirdID2MumMatch
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(PedigreeComparison %>% select(id, dam.class), 
            by = c("BirdID2" = "id")) %>%
  mutate(BirdID2MumMatch = dam.class) %>%
  select(-dam.class)  # Remove dam.class column if not needed

# Remove the unwanted columns R.GRM_1, R.GRM_2, R.GRM_3, and R.GRM_4 from UnintentionalDuplicates
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  select(-R.GRM_1, -R.GRM_2, -R.GRM_3, -R.GRM_4)

#3 can be confirmed comparing with offspring.
#1218/1182. 1182 is probably 1218 because 1218 matches with three different offspring in masterbayes and sequoia
#498/1303. 1303 is probably 498 because 498 has 0.5 relatedness with one offspring (but not the other).
#864/3871. 3871 is probably 864 because 864 matches with offspring.

#Create a BirdIDConsensus column for what the BirdID of the duplicate pair should be
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(BirdIDConsensus = case_when(
    BirdID1 %in% SexMismatches$BirdID ~ as.character(BirdID2),
    BirdID2 %in% SexMismatches$BirdID ~ as.character(BirdID1),
    BirdID1MumMatch == "Match" ~ as.character(BirdID1),
    BirdID2MumMatch == "Match" ~ as.character(BirdID2),
    BirdID1MumRel > 0.5 ~ as.character(BirdID1),
    BirdID2MumRel > 0.5 ~ as.character(BirdID2),
    BirdID1 == 1218 | BirdID2 == 1218 ~ "1218",
    BirdID1 == 498  | BirdID2 == 498  ~ "498",
    BirdID1 == 864  | BirdID2 == 864  ~ "864",
    TRUE ~ NA_character_
  ))

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(BirdIDMissing = case_when(
    BirdID1 == BirdIDConsensus ~ BirdID2,
    BirdID2 == BirdIDConsensus ~ BirdID1,
    TRUE ~ NA_character_
  ))

openxlsx::write.xlsx(UnintentionalDuplicates, file ="UnintentionalDuplicates.xlsx", quote=FALSE)
getwd()

#Re-run sequoia removing the duplicates and only picking the higher coverage sample
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(
    BirdID1Coverage = case_when(
      BirdID1 %in% SequencedIndividualsBirdIDsExtraDeduplicated$BirdID ~ 
        SequencedIndividualsBirdIDsExtraDeduplicated$Coverage[match(BirdID1, SequencedIndividualsBirdIDsExtraDeduplicated$BirdID)],
      TRUE ~ NA_real_
    ),
    BirdID2Coverage = case_when(
      BirdID2 %in% SequencedIndividualsBirdIDsExtraDeduplicated$BirdID ~ 
        SequencedIndividualsBirdIDsExtraDeduplicated$Coverage[match(BirdID2, SequencedIndividualsBirdIDsExtraDeduplicated$BirdID)],
      TRUE ~ NA_real_
    )
  )

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(
    BirdIDtoExclude = case_when(
      BirdID1Coverage > BirdID2Coverage ~ BirdID2,
      BirdID1Coverage < BirdID2Coverage ~ BirdID1,
      TRUE ~ NA_character_
    )
  )



# Ensure BirdIDtoExclude is a character vector for comparison
exclude_values <- as.character(UnintentionalDuplicates$BirdIDtoExclude)

# Check if sw_GenoM_family has row names
if (!is.null(rownames(sw_GenoM_family))) {
  
  # Get the row names of sw_GenoM_family
  row_names <- rownames(sw_GenoM_family)
  
  # Find the values in row_names that are in exclude_values
  rows_to_exclude <- row_names %in% exclude_values
  
  # Exclude the rows from sw_GenoM_family where the row names match exclude_values
  sw_GenoM_family_filtered <- sw_GenoM_family[!rows_to_exclude, , drop = FALSE]
  
  print("Rows have been filtered successfully.")
} else {
  print("sw_GenoM_family does not have row names.")
}

sw_dedup_family_sequoia_justparents <- sequoia(GenoM = sw_GenoM_family_filtered, LifeHistData = lifehist, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

# A 95.1% match to the masterbayes pedigree (1% increase after deduplicating)
sw_dedup_family_pedigree_justparents_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_dedup_family_sequoia_justparents$Pedigree, Plot=TRUE, Symmetrical = TRUE)

SummarySeq(SeqList = sw_family_sequoia_justparents)

#Why are there duplicates?
view(Identifiers)

Identifiers$BirdID<-as.character(SheffieldSubmissions$BirdID)

#It looks like Plate 53 is responsible for 12 duplicates!
UnintentionalDuplicatesMoreInfo<-UnintentionalDuplicates
for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  # Match BirdID1 with Identifiers$BirdID and return Identifiers$Plate in BirdID1Plate
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1Plate[i] <- Identifiers$Plate[match1]
  }
  
  # Match BirdID2 with Identifiers$BirdID and return Identifiers$Plate in BirdID2Plate
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2Plate[i] <- Identifiers$Plate[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1BloodID[i] <- Identifiers$BloodID[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2BloodID[i] <- Identifiers$BloodID[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1BloodTubeNumber[i] <- Identifiers$BTN[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2BloodTubeNumber[i] <- Identifiers$BTN[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1Box[i] <- Identifiers$Box[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2Box[i] <- Identifiers$Box[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1Plate_number[i] <- Identifiers$`Plate Number`[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2Plate_number[i] <- Identifiers$`Plate Number`[match2]
  }
}

#There are 50 samples in Plate 53
sum(Identifiers$Plate == 53, na.rm = TRUE)
#Is Plate 53 also implicated in the sex mismatches? Yes, 12/26 sex-mismatched samples are from Plate 53.
for (i in 1:nrow(SexMismatches)) {
  
  match <- which(Identifiers$BirdID == SexMismatches$BirdID[i])
  
  if (length(match) > 0) {
    SexMismatches$PlateSheffield[i] <- Identifiers$Plate[match]
  }
}

#Of the sequoia mismatches, how many are from Plate 53? 42/156!
# Assuming PedigreeMismatch and Identifiers are data frames
for (i in 1:nrow(PedigreeMismatch)) {
  
  match_id <- which(Identifiers$BirdID == PedigreeMismatch$id[i])
  if (length(match_id) == 1) {  # Ensure exactly one match
    PedigreeMismatch$idPlate[i] <- Identifiers$Plate[match_id]
  } else {
    PedigreeMismatch$idPlate[i] <- NA  # If no match or multiple matches, assign NA
  }
  
  match_dam <- which(Identifiers$BirdID == PedigreeMismatch$dam.1[i])
  if (length(match_dam) == 1) {  # Ensure exactly one match
    PedigreeMismatch$dam.1Plate[i] <- Identifiers$Plate[match_dam]
  } else {
    PedigreeMismatch$dam.1Plate[i] <- NA  # If no match or multiple matches, assign NA
  }
  
  match_sire <- which(Identifiers$BirdID == PedigreeMismatch$sire.1[i])
  if (length(match_sire) == 1) {  # Ensure exactly one match
    PedigreeMismatch$sire.1Plate[i] <- Identifiers$Plate[match_sire]
  } else {
    PedigreeMismatch$sire.1Plate[i] <- NA  # If no match or multiple matches, assign NA
  }
}
count <- sum(
  grepl("53", PedigreeMismatch$idPlate) |
  grepl("53", PedigreeMismatch$dam.1Plate) |
  grepl("53", PedigreeMismatch$sire.1Plate)
)
count

#Explore how Plate53 looks visually. I don't see any pattern here.
IdentifiersPlate53<-subset(Identifiers, Identifiers$Plate == 53)
# Assuming IdentifiersPlate53 is your data frame with columns BirdID and well

# Create an empty matrix to store the BirdID values
result_matrix <- matrix(NA, nrow = 8, ncol = 12)

# Set the row and column names (A to H for rows, 1 to 12 for columns)
rownames(result_matrix) <- LETTERS[1:8]
colnames(result_matrix) <- 1:12

# Loop through each row in IdentifiersPlate53 to assign BirdID to the appropriate place in the matrix
for (i in 1:nrow(IdentifiersPlate53)) {
  # Extract the well location (e.g., "A1", "B2", or "A10", "B11")
  well <- IdentifiersPlate53$well[i]
  
  # Extract the column number (which may have one or two digits)
  # Identify the split point between the letter (row) and the digits (column)
  col_start <- gregexpr("[0-9]", well)[[1]][1]  # Position of the first digit
  col <- as.integer(substr(well, col_start, nchar(well)))  # Extract the column number
  
  # Extract row letter (A to H)
  row <- substr(well, 1, col_start - 1)  # All characters before the digits are the row letter
  
  # Convert row letter (A = 1, B = 2, ..., H = 8)
  row_num <- which(LETTERS[1:8] == row)
  
  # Assign the BirdID to the appropriate place in the result matrix
  result_matrix[row_num, col] <- IdentifiersPlate53$BirdID[i]
}

result_matrix

#Which sex mismatched samples remain to be resolved?
SexMismatchesToResolve <- SexMismatches %>%
  mutate(DuplicateSample = BirdID %in% c(UnintentionalDuplicates$BirdID1, UnintentionalDuplicates$BirdID2))

#11/29 can be resolved as duplicates
#3/29 genomic sex can't reliably be estimated as coverage < 0.32, include as microsatellite sex?
#7/29 I think can be resolved by investigating relationships with close relatives:
  #3088 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 2 blood samples. Mother is #1716 and father is #1774, which is the masterbayes parents of 5145. SWAP WITH 5145.

  #5145 (F, but geno M) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 2 blood samples. Mother is #1429 and father is #1886, which is the masterbayes parents of 3088. SWAP WITH 3088.

  #6156 (M, but geno F) is  #6160.

  #6160 (M, but geno F) is  #5585 (a bird that was a duplicate but now does not have a sample)

  #6166  is male but geno Female, and mother is 4936 and father is 1731, who is masterbayes parents of 5546. SWAP?

  #774 (F, but geno M) never has offspring according to sequoia, and gets replaced by #329 (#1176) as father to #1176. Has 2 blood samples. BrF from 1996-2002. Exclude as 329 is also a mismastched M but geno F.

#8/29 I am not sure how to treat:

  #1229 (M, but geno F) mother is #825 and then inbreeds with #825 to have  an offspring #1537.

  #1435 (M, but geno F) never had offspring according to sequoia, but had three offspring according to masterbayes. Has 4 blood samples and BrM from 2002-2004. Father is #1181. #1435 is related to 870, 1181 and 1052 by > 0.4. 

  #1676 (M, but geno F) never had offspring according to sequoia, but had one offspring according to masterbayes and gets replaced as father by #1695 (who is BrM in neighboring territory 46 vs 45). Has 1 blood sample as ABX. Mother is #1390. SEX CONFLICT IN DATABASE, INCLUDE AS F?

  #5554 (M, but geno F) mismatched parents and also is a sequoia mother to #5773 and #6034, both times replacing #5111. Has 3 blood samples. Mother is #4863 and father is #1762. Related to 5634, 1884, 511, 5553, 1762 > 0.4. Gets assigned female in pre-deduplicated sequoia pedigree and gets assigned male in deduplicated sequoia pedigree. Is this 5511 (F)?

  #5555 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 1 blood sample as FL. Mother is #3500 and father is #1762. #5554 and #5555 are both males so unlikely to have been swapped. Related to 3500 and 1762 > 0.4. 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)?

  #5827 (F, but geno M) never had offspring (mother only is mismatched)- check how it was sexed in database. Has 1 blood sample as FL. Mother is #3086. Related to 3086, 5339, 5598 > 0.35. 3086 has one offspring in Plate 53: 5831 (M). Is this 5831 (M)? then is 5831 actually 5563?

  #6049 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 3 blood samples. Father is #1750, who is masterbayes father of 6165 and 6165 is a missing sample.

  #6149 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 3 blood samples. Mother is #1707 and father is #5822. 1707 and 5822 have an offspring in Plate 53: 6147 (F). Is this 6147 (F)? and then is 6147 actually 5517 (F, also on Plate 53)?


# Subset the SexMismatched data frame where DuplicateSample is FALSE
SexMismatchesToResolve <- SexMismatchesToResolve %>%
  filter(DuplicateSample == FALSE)

# Correct sex mismatches
SexMismatchesToResolve <- SexMismatchesToResolve %>%
  mutate(BirdIDConsensus = case_when(
    BirdID == 1617 ~ 1617,  # coverage too low probably to get correct sex
    BirdID == 3088 ~ 5145,  # (M, but geno F) Mother is #1716 and father is #1774, which is the masterbayes parents of 5145.
    BirdID == 5145 ~ 3088,  # (F, but geno M) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 2 blood samples. Mother is #1429 and father is #1886, which is the masterbayes parents of 3088
    BirdID == 5833 ~ 5833,  # coverage too low probably to get correct sex
    BirdID == 6156 ~ 6160,  # Masterbayes parents
    BirdID == 6160 ~ 5585,  # Sex mismatch female, geno male. Mother is 5164 and father is 2966, which is masterbayes parents of 5585 (sex mismatch male, geno female and missing sample)
    BirdID == 6166 ~ 5546,  # 6166 is male but geno Female, and mother is 4936 and father is 1731, who is masterbayes parents of 5546
    BirdID == 6141 ~ 6141,  # coverage too low probably to get correct sex
    BirdID == 5554 ~ 5511, # (M, but geno F) mismatched parents and also is a sequoia mother to #5773 and #6034, both times replacing #5111. Has 3 blood samples. Mother is #4863 and father is #1762. Related to 5634, 1884, 511, 5553, 1762 > 0.4. Gets assigned female in pre-deduplicated sequoia pedigree and gets assigned male in deduplicated sequoia pedigree. 
    BirdID == 5555 ~ 5512, # Sex mismatched male, but geno female. Mother is 3500 and father is 1762, which is the masterbayes parents of 5512 (Female, but geno male by 2/3 methods). 5555 is 5512, 5512 is 6151 (male), 6151 is 6178 (male), 6178 is 6176 (6176 is a missing sample, male)
  BirdID == 5827 ~ 5831, # (F, but geno M) never had offspring (mother only is mismatched)- check how it was sexed in database. Has 1 blood sample as FL. Mother is #3086. Related to 3086, 5339, 5598 > 0.35. 3086 has one offspring in Plate 53: 5831 (M). 5831 is 5563.
  BirdID == 6049 ~ 6165, # (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 3 blood samples. Father is #1750, who is masterbayes father of 6165 and 6165 is a female and a missing sample.
  BirdID == 6149 ~ 6147, # (M, but geno F) never had offspring (parents only are mismatched). Has 3 blood samples. Mother is #1707 and father is #5822, who are masterbayes parents of 6147. 1707 and 5822 have an offspring in Plate 53: 6147 (F). 5541 is 6149, 6149 is 6147, 6147 is 5517. But 5517 is unknown.
  BirdID == 1668 ~ 1668, # Sexing is incorrect, only one blood sample from 7/24/2002 and conflicts with behavioural method.
  BirdID == 5517  ~ 5836,   # (F, but geno M) never has offspring according to sequoia, and gets replaced by #329 (#1176) as father to #1176. Has 2 blood samples. BrF from 1996-2002.
  BirdID == 774 ~ NA,  # 2 blood samples, and BrF in many years
  BirdID == 1229 ~ NA,  # 2 blood samples for 1 FL, and pedigree mum has masterbayes sequoia conflict. It is likely this bird got mixed up.
  BirdID == 1435 ~ NA,  # 4 blood samples, and pedigree mum has masterbayes sequoia conflict.
  BirdID == 1676 ~ NA,  # 1 blood sample, and pedigree mum has masterbayes sequoia conflict.
  BirdID == 1668 ~ 1668,  # (M but geno F) Sexing is incorrect, only one blood sample from 7/24/2002 and conflicts with behavioural method but sequoia mum matches masterbayes mum
  BirdID == 4893 ~ 4893, #(F, but geno M) CHD gene sexing is incorrect, only one blood sample from 2006. Masyerbayes mum matches sequoia mum
  TRUE ~ NA_real_         # If no condition is met, set BirdIDConsensus to NA (numeric NA)
  ))

PedigreeMismatch <- PedigreeMismatch %>%
  mutate(BirdIDConsensus = case_when(
    #id == 5512  ~ 6151,   # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 5541 ~ 6149,  # Mother is 1852 and father is 4890, which is the masterbayes parents of 6149. 5541 is 6149, 6149 is 6147, 6147 is 5517. But 5517 is unknown. get correct sex
    #id == 5552 ~ 6151,  # 5552 (Female, but Male by 2/3 methods) and 6151 is Male. Mother is 4958 and father is 1710, which is masterbayes parents of 6151
    id == 5562 ~ 5534,  # Female matched. Mother is 2963 and father is 3089, which is masterbayes parents of 5534 (F). 5534 is 6145.
    id == 5831 ~ 5563,  # Male matched. Mother is 3604 and father is 5518, which is masterbayes parents of 5563 (M and a missing sample)
    id == 5832 ~ 5562,  # Female matched. Mother is 1605 and father is 4939, which is masterbayes parents of 5562 (F). 5562 is 6145, 6145 is a missing sample.
    id == 6151 ~ 6178,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6160 ~ 5585,  # Sex mismatch female, geno male. Mother is 5164 and father is 2966, which is masterbayes parents of 5585 (sex mismatch male, geno female and missing sample)
    #id == 6178 ~ 6176,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6147 ~ 5517, # Replaces 5517 as mother to 6668, who has father 5837 that masterbayes and sequoia agrees with
    id == 5511 ~ 6150, # probably is 6150 (Female), genomic father is 3456, I searched for 3456's offsprings and found 2 individuals overlaped with samples in plate 53, 6136 and 6150, 6136 was be identified and is Male, so I guess is 6150
    id == 5534 ~ 6145, # Female matches. Mother is 5514, who is 6145's mother in masterbayes. 5534 also replaces 6145 as maserbayes mother. 6145 is female and a missing sample
    id == 5687 ~ 5538, # 5687 (male) sequoia parents are 3567 and 1604 which is the masterbayes parents of 5538 (male)
    id == 5781 ~ 6140, # 5781 father is 5586 and this is the sequoia father of 6140, which is currently missing a sample
    id == 5538 ~ 6166, # 5781 father is 5586 and this is the sequoia father of 6140, which is currently missing a sample
    TRUE ~ NA_real_         # If no condition is met, set BirdIDConsensus to NA (numeric NA)
  ))

TestPedigreeMismatchSubset <- TestPedigreeMismatchSubset %>%
  mutate(BirdIDConsensus = case_when(
    #id == 5512  ~ 6151,   # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 5541 ~ 6149,  # Mother is 1852 and father is 4890, which is the masterbayes parents of 6149. 5541 is 6149, 6149 is 6147, 6147 is 5517. But 5517 is unknown. get correct sex
    #id == 5552 ~ 6151,  # 5552 (Female, but Male by 2/3 methods) and 6151 is Male. Mother is 4958 and father is 1710, which is masterbayes parents of 6151
    id == 5562 ~ 5534,  # Female matched. Mother is 2963 and father is 3089, which is masterbayes parents of 5534 (F). 5534 is 6145.
    id == 5831 ~ 5563,  # Male matched. Mother is 3604 and father is 5518, which is masterbayes parents of 5563 (M and a missing sample)
    id == 5832 ~ 5562,  # Female matched. Mother is 1605 and father is 4939, which is masterbayes parents of 5562 (F). 5562 is 6145, 6145 is a missing sample.
    id == 6151 ~ 6178,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6160 ~ 5585,  # Sex mismatch female, geno male. Mother is 5164 and father is 2966, which is masterbayes parents of 5585 (sex mismatch male, geno female and missing sample)
    #id == 6178 ~ 6176,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6147 ~ 5517, # Replaces 5517 as mother to 6668, who has father 5837 that masterbayes and sequoia agrees with
    id == 5511 ~ 6150, # probably is 6150 (Female), genomic father is 3456, I searched for 3456's offsprings and found 2 individuals overlaped with samples in plate 53, 6136 and 6150, 6136 was be identified and is Male, so I guess is 6150
    id == 5534 ~ 6145, # Female matches. Mother is 5514, who is 6145's mother in masterbayes. 5534 also replaces 6145 as maserbayes mother. 6145 is female and a missing sample
    id == 5687 ~ 5538, # 5687 (male) sequoia parents are 3567 and 1604 which is the masterbayes parents of 5538 (male)
    id == 5781 ~ 6140, # 5781 father is 5586 and this is the sequoia father of 6140, which is currently missing a sample
    id == 5538 ~ 6166, # 5781 father is 5586 and this is the sequoia father of 6140, which is currently missing a sample
    TRUE ~ NA_real_         # If no condition is met, set BirdIDConsensus to NA (numeric NA)
  ))

# Initialize the new columns with FALSE
IdentifiersPlate53$Duplicate <- FALSE
IdentifiersPlate53$SexMismatches <- FALSE
IdentifiersPlate53$ParentsMismatched <- FALSE

# Check for matches between BirdID and BirdID1 or BirdID2 in UnintentionalDuplicatesMoreInfo
IdentifiersPlate53$Duplicate <- IdentifiersPlate53$BirdID %in% c(UnintentionalDuplicatesMoreInfo$BirdID1, UnintentionalDuplicatesMoreInfo$BirdID2)

# Check for matches between BirdID and BirdID in SexMismatched
IdentifiersPlate53$SexMismatches <- IdentifiersPlate53$BirdID %in% SexMismatchesToResolve$BirdID


# Check for matches between BirdID and id in PedigreeMismatch
IdentifiersPlate53$ParentsMismatched <- IdentifiersPlate53$BirdID %in% PedigreeMismatch$id

# Initialize the new column in IdentifiersPlate53
IdentifiersPlate53$BirdIDConsensus <- NA

# For UnintentionalDuplicatesMoreInfo (matching BirdID to BirdID1 or BirdID2)
for (i in 1:nrow(IdentifiersPlate53)) {
  bird_id <- IdentifiersPlate53$BirdID[i]
  
  # Check if BirdID matches either BirdID1 or BirdID2 in UnintentionalDuplicatesMoreInfo
  match_duplicate1 <- UnintentionalDuplicatesMoreInfo$BirdID1 == bird_id
  match_duplicate2 <- UnintentionalDuplicatesMoreInfo$BirdID2 == bird_id
  match_duplicate <- match_duplicate1 | match_duplicate2
  
  # If matched and BirdIDConsensus is not NA, assign it to IdentifiersPlate53$BirdIDConsensus
  if (any(match_duplicate)) {
    consensus_value <- UnintentionalDuplicatesMoreInfo$BirdIDConsensus[match_duplicate]
    if (length(consensus_value) == 1 && !is.na(consensus_value)) {
      IdentifiersPlate53$BirdIDConsensus[i] <- consensus_value
    }
  }
}

# For SexMismatched (matching BirdID to BirdID)
for (i in 1:nrow(IdentifiersPlate53)) {
  bird_id <- IdentifiersPlate53$BirdID[i]
  
  # Check if BirdID matches BirdID in SexMismatched
  match_sex_mismatch <- SexMismatchesToResolve$BirdID == bird_id
  if (any(match_sex_mismatch)) {
    consensus_value <- SexMismatchesToResolve$BirdIDConsensus[match_sex_mismatch]
    if (length(consensus_value) == 1 && !is.na(consensus_value)) {
      IdentifiersPlate53$BirdIDConsensus[i] <- consensus_value
    }
  }
}


# For PedigreeMismatch (matching BirdID to id)
for (i in 1:nrow(IdentifiersPlate53)) {
  bird_id <- IdentifiersPlate53$BirdID[i]
  
  # Check if BirdID matches id in PedigreeMismatch
  match_parents_mismatch <- PedigreeMismatch$id == bird_id
  if (any(match_parents_mismatch)) {
    consensus_value <- PedigreeMismatch$BirdIDConsensus[match_parents_mismatch]
    if (length(consensus_value) == 1 && !is.na(consensus_value)) {
      IdentifiersPlate53$BirdIDConsensus[i] <- consensus_value
    }
  }
}

openxlsx::write.xlsx(IdentifiersPlate53, file ="Plate53.xlsx", quote=FALSE)
getwd()

# Of the duplicate pair samples, exclude the sample with poorer coverage
Seychelles_warbler_traits <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  filter(!BirdID %in% UnintentionalDuplicates$BirdIDtoExclude)

# Exclude rows where we can't verify the sample because it is sex mismatched
Seychelles_warbler_traits <- Seychelles_warbler_traits %>%
  filter(!(BirdID %in% SexMismatchesToResolve$BirdID & 
           is.na(SexMismatchesToResolve$BirdIDConsensus[match(BirdID, SexMismatchesToResolve$BirdID)])))

# Exclude rows where we can't verify the sample because it is on Plate 53 and pedigree mismatched
Seychelles_warbler_traits <- Seychelles_warbler_traits %>%
  filter(!(BirdID %in% IdentifiersPlate53$BirdID & 
           is.na(IdentifiersPlate53$BirdIDConsensus[match(BirdID, IdentifiersPlate53$BirdID)]) & 
           IdentifiersPlate53$ParentsMismatched[match(BirdID, IdentifiersPlate53$BirdID)] == TRUE))

#Correct the BirdIDs for duplicates, and mixups

#testing
Seychelles_warbler_traits$BirdIDConsensus <- NA
# Ensure the BirdIDConsensus column exists and initialize if necessary
if (!"BirdIDConsensus" %in% colnames(Seychelles_warbler_traits)) {
  Seychelles_warbler_traits$BirdIDConsensus <- NA  # Initialize it as NA if it doesn't exist
}

# Loop through the rows of Seychelles_warbler_traits
for (i in 1:nrow(Seychelles_warbler_traits)) {
  bird_id <- Seychelles_warbler_traits$BirdID[i]
  
  # Only proceed if BirdID is not NA
  if (!is.na(bird_id)) {
    
    # Step 2: Condition 1: Match with UnintentionalDuplicates$BirdID1 or UnintentionalDuplicates$BirdID2
    if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i])) {
      if (bird_id %in% UnintentionalDuplicates$BirdID1) {
        idx <- match(bird_id, UnintentionalDuplicates$BirdID1)
        Seychelles_warbler_traits$BirdIDConsensus[i] <- UnintentionalDuplicates$BirdIDConsensus[idx]
      } else if (bird_id %in% UnintentionalDuplicates$BirdID2) {
        idx <- match(bird_id, UnintentionalDuplicates$BirdID2)
        Seychelles_warbler_traits$BirdIDConsensus[i] <- UnintentionalDuplicates$BirdIDConsensus[idx]
      }
    }

    # Step 3: Condition 2: Match with SexMismatchesToResolve$BirdID (only if BirdIDConsensus is still NA)
    if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i]) && bird_id %in% SexMismatchesToResolve$BirdID) {
      idx <- match(bird_id, SexMismatchesToResolve$BirdID)
      Seychelles_warbler_traits$BirdIDConsensus[i] <- SexMismatchesToResolve$BirdIDConsensus[idx]
    }

    # Step 4: Correct pedigree mismatched but sex matched samples
    if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i]) && bird_id %in% TestPedigreeMismatchSubset$id) {
      idx <- match(bird_id, TestPedigreeMismatchSubset$id)  # Match BirdID with PedigreeMismatch
      Seychelles_warbler_traits$BirdIDConsensus[i] <- TestPedigreeMismatchSubset$BirdIDConsensus[idx]  # Assign BirdIDConsensus
    }
  }
  
  # Add a debug statement to track progress
  if (i %% 100 == 0) {
    cat("Processed ", i, " rows\n")
  }
}

# Step 5: Fill remaining NAs with the original BirdID if BirdIDConsensus is still empty
Seychelles_warbler_traits$BirdIDConsensus[is.na(Seychelles_warbler_traits$BirdIDConsensus)] <- Seychelles_warbler_traits$BirdID[is.na(Seychelles_warbler_traits$BirdIDConsensus)]


##### Delete probs #####
# Step 5: Fill remaining NAs with the original BirdID if BirdIDConsensus is still empty
Seychelles_warbler_traits$BirdIDConsensus[is.na(Seychelles_warbler_traits$BirdIDConsensus)] <- Seychelles_warbler_traits$BirdID[is.na(Seychelles_warbler_traits$BirdIDConsensus)]

# Step 1: Initialize BirdIDConsensus column with NA
Seychelles_warbler_traits$BirdIDConsensus <- NA

# Step 2: Condition 1: Match with UnintentionalDuplicates$BirdID1 or UnintentionalDuplicates$BirdID2
for (i in 1:nrow(Seychelles_warbler_traits)) {
  bird_id <- Seychelles_warbler_traits$BirdID[i]
  
  # Check if the BirdID matches either BirdID1 or BirdID2 from UnintentionalDuplicates
  if (bird_id %in% UnintentionalDuplicates$BirdID1) {
    idx <- match(bird_id, UnintentionalDuplicates$BirdID1)
    Seychelles_warbler_traits$BirdIDConsensus[i] <- UnintentionalDuplicates$BirdIDConsensus[idx]
  } else if (bird_id %in% UnintentionalDuplicates$BirdID2) {
    idx <- match(bird_id, UnintentionalDuplicates$BirdID2)
    Seychelles_warbler_traits$BirdIDConsensus[i] <- UnintentionalDuplicates$BirdIDConsensus[idx]
  }
}

# Step 3: Condition 2: Match with SexMismatchesToResolve$BirdID (only if BirdIDConsensus is NA)
for (i in 1:nrow(Seychelles_warbler_traits)) {
  bird_id <- Seychelles_warbler_traits$BirdID[i]
  
  # Only fill BirdIDConsensus if it's still NA
  if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i]) && bird_id %in% SexMismatchesToResolve$BirdID) {
    idx <- match(bird_id, SexMismatchesToResolve$BirdID)
    Seychelles_warbler_traits$BirdIDConsensus[i] <- SexMismatchesToResolve$BirdIDConsensus[idx]
  }
}

# Step 4: Correct pedigree mismatched but sex matched samples
for (i in 1:nrow(Seychelles_warbler_traits)) {
  bird_id <- Seychelles_warbler_traits$BirdID[i]
  
  # Only fill BirdIDConsensus if it's still NA
  if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i]) && bird_id %in% PedigreeMismatch$id) {
    idx <- match(bird_id, PedigreeMismatch$id)  # Match BirdID with PedigreeMismatch
    Seychelles_warbler_traits$BirdIDConsensus[i] <- PedigreeMismatch$BirdIDConsensus[idx]  # Assign BirdIDConsensus
  }
}

# Step 5: Fill remaining NAs with the original BirdID if BirdIDConsensus is still empty
Seychelles_warbler_traits$BirdIDConsensus[is.na(Seychelles_warbler_traits$BirdIDConsensus)] <- Seychelles_warbler_traits$BirdID[is.na(Seychelles_warbler_traits$BirdIDConsensus)]
##### ##### 

# Relink life-history
#Create life history data file
LifeHistoryData <- SequencedIndividualsBirdIDsExtraDeduplicated[, c("BirdID", "Sex","Lifespan","BirthYear","LastSeenYear","ReproductiveOutput")]

# Create genomic data 
GenomicData <- Seychelles_warbler_traits[, !colnames(Seychelles_warbler_traits) %in% c("BirdID", "Sex", "Lifespan", "BirthYear", "LastSeenYear", "ReproductiveOutput")]
GenomicData$BirdID <- GenomicData$BirdIDConsensus

# Merge life-history data with genomic data, corrected for sample ID
SeychellesWarblerTraitsCorrected <- merge(GenomicData, LifeHistoryData, by = "BirdID", all.x = TRUE)



# How does the genomic sexing plot look now?
#Run the sexing model and check any sex mismatches
#Build model 
logisticSexModelCorrected <- glm(Sex ~ cbind(Z_cov,(Coverage)) + cbind(nHet,nHom), 
                     data = subset(SeychellesWarblerTraitsCorrected,SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01) , 
                     family = "binomial")
#Assign sex based off model
predicted_probs <- predict(logisticSexModelCorrected, SeychellesWarblerTraitsCorrected, type = "response")
predicted_sex <- ifelse(predicted_probs > 0.5, "1", "0")

# Add the predicted sex to the data
SeychellesWarblerTraitsCorrected$PredictedSex <- predicted_sex

# Identify rows where CHD gene sex does not match the predicted sex
SexMismatchesCorrected <- SeychellesWarblerTraitsCorrected[SeychellesWarblerTraitsCorrected$Sex != SeychellesWarblerTraitsCorrected$PredictedSex, ]


# Create the plot with geom_text_repel to prevent label overlap
ggplot(subset(SeychellesWarblerTraitsCorrected, SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01), aes(x = Z_cov/Coverage, y = Het, color = as.factor(Sex))) +
  geom_point() +  # Scatter plot of the data
  labs(x = "Z coverage", y = "Het", title = "Proportional Z Chr. Coverage by Z Chr Heterozygosity") +
  theme_minimal() +  # Minimal theme
  scale_color_manual(values = c("red", "blue")) +  # Color for sexes
  geom_text_repel(data = subset(SexMismatchesCorrected,SexMismatchesCorrected$ProportionalZCoverage<0.01) , 
                  aes(x = ProportionalZCoverage, y = Het, label = BirdID), 
                  color = "black", 
                  size = 4,  # Adjust label size
                  box.padding = 0.5,  # Space between label and point
                  max.overlaps = 50,  # Limit the number of overlaps (e.g., 50 labels can overlap)
                  force = 2,  # Set force to avoid excessive movement of labels
                  max.iter = 1000,  # Limit number of iterations for adjusting the labels
                  segment.size = 0.5) +  # Adjust the segment size connecting the labels
  xlim(min(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) - 0, max(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) + 0) +  # Adjust plot limits
  ylim(min(SeychellesWarblerTraitsCorrected$Het) - 0, max(SeychellesWarblerTraitsCorrected$Het) + 0)  # Adjust plot limits

#The model picks up 1668 (M but geno F) with only one blood sample from 7/24/2002 and conflicts with behavioral method but sequoia mum matches masterbayes mum, so we change sex to F. The bird has no offspring.
#The model does not pick up 4893 well, but we can see from the plot that it should be change to Male as sequoia mum matches the masterbayes mum. the bird has no offspring.
LifeHistoryData <- LifeHistoryData %>%
  mutate(Sex = as.numeric(as.character(Sex)),  # Convert factor to numeric
         Sex = case_when(
           BirdID == 1668 ~ 0,   # Set Sex to 0 for BirdID 1668
           BirdID == 4893 ~ 1,   # Set Sex to 1 for BirdID 4893
           TRUE ~ Sex            # Keep original value for other rows
         ))

# Re-merge life-history data with genomic data, corrected for sample ID
SeychellesWarblerTraitsCorrected <- merge(GenomicData, LifeHistoryData, by = "BirdID", all.x = TRUE)

# How does the genomic sexing plot look now?
#Run the sexing model and check any sex mismatches
#Build model 
logisticSexModelCorrected <- glm(Sex ~ cbind(Z_cov,(Coverage)) + cbind(nHet,nHom), 
                     data = subset(SeychellesWarblerTraitsCorrected,SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01) , 
                     family = "binomial")
#Assign sex based off model
predicted_probs <- predict(logisticSexModelCorrected, SeychellesWarblerTraitsCorrected, type = "response")
predicted_sex <- ifelse(predicted_probs > 0.5, "1", "0")

# Add the predicted sex to the data
SeychellesWarblerTraitsCorrected$PredictedSex <- predicted_sex

# Identify rows where CHD gene sex does not match the predicted sex
SexMismatchesCorrected <- SeychellesWarblerTraitsCorrected[SeychellesWarblerTraitsCorrected$Sex != SeychellesWarblerTraitsCorrected$PredictedSex, ]

# Create the plot with geom_text_repel to prevent label overlap
ggplot(subset(SeychellesWarblerTraitsCorrected, SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01), aes(x = Z_cov/Coverage, y = Het, color = as.factor(Sex))) +
  geom_point() +  # Scatter plot of the data
  labs(x = "Z coverage", y = "Het", title = "Proportional Z Chr. Coverage by Z Chr Heterozygosity") +
  theme_minimal() +  # Minimal theme
  scale_color_manual(values = c("red", "blue")) +  # Color for sexes
  xlim(min(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) - 0, max(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) + 0) +  # Adjust plot limits
  ylim(min(SeychellesWarblerTraitsCorrected$Het) - 0, max(SeychellesWarblerTraitsCorrected$Het) + 0)  # Adjust plot limits

#Re- run sequoia pedigree and relatedness plot. Then find out other samples where both parents mismatched and see if can find correct parent. Write up the methods. TO DO.
#Output list of correct samples
DeduplicatedforSequoiaCorrect<-data.frame(rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$Filepath)
write.table(DeduplicatedforSequoiaCorrect, file = "DeduplicatedforSequoiaCorrect.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Rename samples for sequioa to BirdIDs
RenameforSequoiaCorrected<-data.frame(rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$Filepath,rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$BirdID)

write.table(RenameforSequoiaCorrected, file = "RenameforSequoiaCorrected.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)



#Comparing genomic relatedness to masterbayes pedigree relatedness and to sequoia pedigree relatedness
#Rped.old<-CalcRped(masterped, OUT="DF")
#Rel.snp<- read.table("Corrected.grm", stringsAsFactors = FALSE)
#Rel.id <- read.table("Corrected.grm.id", stringsAsFactors=FALSE)
#Rped.new<-CalcRped(sw_family_sequoia_justparents_corrected[["PedigreePar"]], OUT = "DF")
#Rel.id<-merge(Rel.id, RenameforSequoiaCorrected, by.x='V2', by.y='SeychellesWarblerTraitsCorrected.Filepath') %>% select(V1,SeychellesWarblerTraitsCorrected.BirdID)
#Rel.snp[,1] <- as.character(factor(Rel.snp[,1], labels=Rel.id[,2]))
#Rel.snp[,2] <- as.character(factor(Rel.snp[,2], labels=Rel.id[,2]))
#names(Rel.snp) <- c("IID1", "IID2", "nSNPS", "R.GRM")
#Rel.snp <- Rel.snp[Rel.snp$IID1 != Rel.snp$IID2,] 

#Rel.both.old <- merge(data.table(Rel.snp[,c(1,2,4)], key=c("IID1", "IID2")),
#                  data.table(Rped.old, key=c("IID1", "IID2")), all.x=TRUE)

#round(cor(Rel.both.old[, c("R.GRM","R.ped")],use="pairwise.complete"), 3)
#hexbin::hexbinplot(Rel.both.old$R.GRM ~ Rel.both.old$R.ped,
#                   xbins=100, aspect=1, 
#                   xlim=c(0.05,1), ylim=c(-.7, 2.8),
#                   xlab="Pedigree relatedness", ylab="Genomic relatedness",
#                   trans=log10, inv=function(x) 10^x,
#                   colorcut=seq(0,1,length=14), maxcnt=10^6.5,
#                   colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')})

#Rel.both.new <- merge(data.table(Rel.snp[,c(1,2,4)], key=c("IID1", "IID2")),
#                  data.table(Rped.new, key=c("IID1", "IID2")), all.x=TRUE)
#round(cor(Rel.both.new[, c("R.GRM","R.ped")],use="pairwise.complete"), 3)
#hexbin::hexbinplot(Rel.both.new$R.GRM ~ Rel.both.new$R.ped,
#                   xbins=100, aspect=1, 
#                   xlim=c(0.05,1), ylim=c(-.7, 2.8),
#                   xlab="Pedigree relatedness", ylab="Genomic relatedness",
#                   trans=log10, inv=function(x) 10^x,
#                   colorcut=seq(0,1,length=14), maxcnt=10^6.5,
#                   colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')})

#hb <- hexbin::hexbin(Rel.both$R.GRM ~ Rel.both$R.ped,
#                     xbins=100, xbnds=c(-.05, 2), ybnds=c(-.7, 2.8),
#                     xlab="Pedigree relatedness", ylab="Genomic relatedness")
#hbp <- hexbin::plot(hb,
#                                  trans=log10, inv=function(x) 10^x,
#                                  colorcut=seq(0,1,length=14), maxcnt=10^6.5,
#                                  colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')}
#                                  )
#hexbin::hexVP.abline(hbp$plot.vp, lm(Rel.both$R.GRM ~ Rel.both$R.ped))



sw_GenoM_family_corrected <- GenoConvert(InFile = "reimputedinputfile_for_sequoia_corrected.raw", InFormat="raw")

lifehistcorrected <- lifehist %>%
  mutate(Sex = as.numeric(as.character(Sex)),  # Convert factor to numeric
         Sex = case_when(
           BirdID == 1668 ~ 0,   # Set Sex to 0 for BirdID 1668
           BirdID == 4893 ~ 1,   # Set Sex to 1 for BirdID 4893
           TRUE ~ Sex            # Keep original value for other rows
         ))

# Just parentage assignment (Module = "par"). 
sw_family_sequoia_justparents_corrected <- sequoia(GenoM = sw_GenoM_family_corrected, LifeHistData = lifehistcorrected, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

sw_family_pedigree_justparents_corrected_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents_corrected$Pedigree, Plot=TRUE, Symmetrical = TRUE)


openxlsx::write.xlsx(sw_family_sequoia_justparents_corrected[["PedigreePar"]], file ="PedigreeCorrected.xlsx", quote=FALSE)

masterpedconfident <- read.csv("pedFINAL_var124567_combined_unique_20230413.csv")
names(masterpedconfident)[names(masterpedconfident) == 'dad'] <- 'sire'
names(masterpedconfident)[names(masterpedconfident) == 'mum'] <- 'dam'
masterpedconfident<-subset(masterpedconfident, masterpedconfident$p>0.8)
masterpedconfident <- masterpedconfident[-c(4)]

sw_family_pedigree_justparents_corrected_comparison <- PedCompare(masterpedconfident[,c("id", "dam", "sire")], sw_family_sequoia_justparents_corrected$Pedigree, Plot=TRUE, Symmetrical = TRUE)


openxlsx::write.xlsx(sw_family_pedigree_justparents_corrected_comparison[["Mismatch"]], file ="PedigreeMismatchesCorrectedMasyerbayesConfident.xlsx", quote=FALSE)

```

## Sex prediction

Now that we have verified and cleaned sample mismatches, we now have a model to sex future whole-genome sequenced Seychelles warblers

```{r demographic_history, eval = TRUE, echo = TRUE, tidy=FALSE}
# Predict the probability for a newly sequenced individual (e.g., for a given individual with specific Het and ProportionalZCoverage values)
new_individual <- data.frame(Het = 0.07, Z_cov = 0.0025, Coverage=5, nHet=10000, nHom=10000)  # Replace with actual values for the individual
predicted_prob <- predict(logisticSexModel, new_individual, type = "response")

# Convert predicted probability to sex prediction (e.g., using a threshold of 0.5)
predicted_sex <- ifelse(predicted_prob > 0.5, "Male", "Female")

# View the prediction
predicted_sex

ggplot(subset(SeychellesWarblerTraitsCorrected, SeychellesWarblerTraitsCorrected$ProportionalZCoverage < 0.01), 
       aes(x = Z_cov / Coverage, y = Het, color = as.factor(Sex))) +
  geom_point() +  # Scatter plot of the data
  labs(x = "Z coverage", y = "Het", title = "Proportional Z Chr. Coverage by Z Chr Heterozygosity") +
  theme_minimal() +  # Minimal theme
  scale_color_manual(values = c("red", "blue")) +  # Color for sexes
  # Add trend line for each sex group
  geom_smooth(method = "lm", aes(group = Sex), se = TRUE, linetype = "solid") +  # Add trend line (linear model)
  xlim(min(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) - 0, 
       max(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) + 0) +  # Adjust plot limits
  ylim(min(SeychellesWarblerTraitsCorrected$Het) - 0, 
       max(SeychellesWarblerTraitsCorrected$Het) + 0)  # Adjust plot limits



```

## Inbreeding depression

Investigate co-variation between individual inbreeding coefficients and key life-history traits lifespan and lifetime fecundity. It looks like there is more evidence of inbreeding depression from recent inbreeding. I diverged from control variables https://osf.io/tsxv9 as pre-registered here: 1) excluding number of Helpers in territory because this effect is environmentally-dependent (too many helpers are bad) 2) excluding dam id, but keeping sire id because sire id is much more variable than is dam id and we don't want to overfit the model 3) excluding insect counts because these may no longer be measured well as most habitat is well beyond reach of humans, but instead including mean death rate between field seasons as an environmental control of lifetime hardship faced.

```{r inbreeding_depression, eval = TRUE, echo = TRUE}
##Inbreeding (FROH) depression (Lifespan and N offspring produced in lifetime)
LargeROHxLifespan<-ggplot(dplyr::filter(SeychellesWarblerTraitsCorrected), aes(x=LargeFROHbin, y=Lifespan)) + geom_point() + geom_smooth(method='lm') 
LargeROHxLifespan

MediumROHxLifespan<-ggplot(dplyr::filter(SeychellesWarblerTraitsCorrected), aes(x=MediumFROHbin, y=Lifespan)) + geom_point() + geom_smooth(method='lm') 
MediumROHxLifespan

SmallROHxLifespan<-ggplot(dplyr::filter(SeychellesWarblerTraitsCorrected), aes(x=SmallFROHbin, y=Lifespan)) + geom_point() + geom_smooth(method='lm') 
SmallROHxLifespan

LargeROHxFecundity<-ggplot(dplyr::filter(SeychellesWarblerTraitsCorrected), aes(x=LargeFROHbin, y=ReproductiveOutput)) + geom_point() + geom_smooth(method='lm') 
LargeROHxFecundity

MediumROHxFecundity<-ggplot(dplyr::filter(SeychellesWarblerTraitsCorrected), aes(x=MediumFROHbin, y=ReproductiveOutput)) + geom_point() + geom_smooth(method='lm') 
MediumROHxFecundity

SmallROHxFecundity<-ggplot(dplyr::filter(SeychellesWarblerTraitsCorrected), aes(x=SmallFROHbin, y=ReproductiveOutput)) + geom_point() + geom_smooth(method='lm') 
SmallROHxFecundity

#Add in covariables:
#Mean death rate per year

death_rate_df <- BirdIDSexYear %>%
  group_by(FieldPeriodID) %>%
  summarise(unique_birds = n_distinct(BirdID)) %>%
  arrange(FieldPeriodID) %>%
  mutate(

    death_rate = (lead(unique_birds, order_by = FieldPeriodID) - unique_birds) / unique_birds,

    unique_birds_next_fieldperiod = lead(unique_birds, order_by = FieldPeriodID)
  ) %>%
  filter(!is.na(death_rate)) %>%
  select(FieldPeriodID, unique_birds, unique_birds_next_fieldperiod, death_rate)

bird_death_rate <- BirdIDSexYear %>%
  left_join(death_rate_df, by = "FieldPeriodID") %>%
  select(BirdID, death_rate)

mean_death_rate_per_bird <- bird_death_rate %>%
  group_by(BirdID) %>%
  summarise(MeanLifetimeDeathRate = mean(death_rate, na.rm = TRUE))

mean_death_rate_per_bird$BirdID<-as.character(mean_death_rate_per_bird$BirdID)
SeychellesWarblerTraitsCorrected <- SeychellesWarblerTraitsCorrected %>%
  left_join(mean_death_rate_per_bird, by = "BirdID")

#Maternal ages
SequoiaPedigree<-(sw_family_pedigree_justparents_corrected_comparison[["ConsensusPed"]])
SequoiaPedigree <- SequoiaPedigree %>%
  rename(dam = dam.c) %>%
  rename(sire = sire.c)
BirthDate$BirdID<-as.character(BirthDate$BirdID)

SequoiaPedigree <- SequoiaPedigree %>%
  left_join(BirthDate, by = c("id" = "BirdID")) %>%
  rename(OffspringBirthDate = BirthDate)  # Renaming for clarity

SequoiaPedigree <- SequoiaPedigree %>%
  left_join(BirthDate, by = c("dam" = "BirdID")) %>%
  rename(DamBirthDate = BirthDate)  # Renaming for clarity

SequoiaPedigree <- SequoiaPedigree %>%
  mutate(
    MaternalAge = as.numeric(difftime(OffspringBirthDate, DamBirthDate, units = "weeks")) / 52.25  # Convert weeks to years
  )

SeychellesWarblerTraitsCorrected <- SeychellesWarblerTraitsCorrected %>%
  left_join(SequoiaPedigree %>%
              select(id, MaternalAge), by = c("BirdID" = "id"))

SeychellesWarblerTraitsCorrected <- SeychellesWarblerTraitsCorrected %>%
  left_join(SequoiaPedigree %>% select(id, dam, sire), by = c("BirdID" = "id"))

SeychellesWarblerTraitsCorrected <- SeychellesWarblerTraitsCorrected %>%
  rename(DamID = dam) %>%
  rename(SireID = sire)


#Build models
LifespanInbreedingDepression <- lmer(Lifespan ~ LargeFROHbin + MediumFROHbin + SmallFROHbin + Sex + MeanLifetimeDeathRate + MaternalAge + Coverage + (1 | SireID) ,
              data = SeychellesWarblerTraitsCorrected)

summary(LifespanInbreedingDepression)

LifetimeFecundityInbreedingDepression <- lmer(ReproductiveOutput ~ LargeFROHbin + MediumFROHbin + SmallFROHbin + Sex + MeanLifetimeDeathRate + MaternalAge + Coverage + (1 | SireID),
              data = SeychellesWarblerTraitsCorrected)

summary(LifetimeFecundityInbreedingDepression)

openxlsx::write.xlsx(SeychellesWarblerTraitsCorrected, file ="SeychellesWarblerTraitsCorrected.xlsx", quote=FALSE)
getwd()

```

## Inbreeding avoidance

Calculate relatedness of all pedigree pairs and how that matches up to pairwise relatedness of all adults that were alive at the same time. Sen and Sergio have done some work here, we can help each other out.
Check out 10.1111/jeb.13376 

```{r inbreeding_avoidance, eval = TRUE, echo = TRUE}


# Ensure the necessary columns are of the same type (character)
Lifespan$BirdID <- as.character(Lifespan$BirdID)


# Merge Rel.both with Lifespan for IID1 and IID2
Rel.both.alive <- Rel.both %>%
  left_join(Lifespan, by = c("IID1" = "BirdID"), suffix = c("_1", "_"))
Rel.both.alive <- Rel.both.alive %>%
  left_join(Lifespan, by = c("IID2" = "BirdID"), suffix = c("_1", "_2"))

# Check for overlap in BirthYear and LastSeenYear
Rel.both.alive <- Rel.both.alive %>%
  filter(BirthYear_1 <= LastSeenYear_2 & BirthYear_2 <= LastSeenYear_1)

masterped_nonmissing <- masterped[!is.na(masterped$dam) & !is.na(masterped$sire), ]

# Ensure both are data frames
masterped_nonmissing <- as.data.frame(masterped_nonmissing)
Rel.both.alive <- as.data.frame(Rel.both.alive)

# Create a helper column to represent the two possible pairings
masterped_nonmissing$pair1 <- paste(masterped_nonmissing$dam, masterped_nonmissing$sire, sep = "_")
masterped_nonmissing$pair2 <- paste(masterped_nonmissing$dam, masterped_nonmissing$sire, sep = "_")

# Create a new column in Rel.both.alive for the pair combination of IID1 and IID2
Rel.both.alive$pair <- paste(Rel.both.alive$IID1, Rel.both.alive$IID2, sep = "_")

# Subset Rel.both.alive to include only rows where the pair is present in masterped_nonmissing
Rel.both.alive.partners <- Rel.both.alive %>%
  filter(pair %in% masterped_nonmissing$pair1 | pair %in% masterped_nonmissing$pair2)


# Calculate the mean of Rel.both.alive.partners$R.GRM
mean_R_GRM <- mean(Rel.both.alive.partners$R.GRM, na.rm = TRUE)
mean_R_GRM
# Create a ggplot2 histogram for Rel.both.alive$R.GRM with the mean line
ggplot(Rel.both.alive, aes(x = R.GRM)) +
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black", alpha = 0.7) +
  geom_vline(xintercept = mean_R_GRM, color = "red", linetype = "dashed", size = 1.5) +
  labs(title = "Histogram of R.GRM", x = "R.GRM", y = "Frequency") +
  theme_minimal()

rm(Rel.both)
rm(Rel.both.alive)
```

## Functional annotations

Script adapted from Chuen Zhang Lee.

```{r annotations, eval = FALSE, echo = TRUE}
# read in eggnog output
seywarbler <- read_tsv("out.emapper.decorated.gff",col_names = FALSE)
# give it column names
colnames(seywarbler) <- c("geneno", "source", "feature", "start", "end", "score",
                          "strand", "frame", "attribute")

# read in GALBA output (with chromosome positions)
seygalba <- read_csv("galba2.gff3.csv",col_names = FALSE)
colnames(seygalba) <- c("CHR_name","CHR_rag", "source", "feature", "start", "end", "score",
                        "strand", "frame", "attribute","geneno")

# read in chromosome names
seychrom <- read_csv("Chromosomenames_Chr.csv")

# merge chromosome names with galba - this give actual chromosome numbers as "CHR"
seychromgalba <- merge(seygalba,seychrom, by="CHR_name",all=T) %>% mutate(CHR = replace_na(CHR,"0"))

# merge eggNOG with updated GALBA - this gives actual gene annotations as "attribute.y"
seyall <- seywarbler %>% dplyr::select(geneno,source,attribute) %>% merge(seychromgalba,., by=c("geneno"),all=T)

# make it into proper .gff format to export
swgff <- seyall %>% mutate(source = "AUGUSTUS_eggNOGmapper") %>% dplyr::select(CHR,source,feature,start,end,score,strand,frame,attribute.x,attribute.y)
#write as tsv, can rename so it reads as .gff if wanted
#write_tsv(swgff,"~/Documents/PhD/R_analysis/Genomics/InputTables/sw_eggnog_gff.tsv")

# this is number of genes per chromsome. 
numberofgenesperchrom <- swgff %>% group_by(CHR) %>% summarise(n())
number_of_genes_per_chrom <- swgff %>%
  group_by(CHR) %>%
  summarise(number_of_genes = n()) %>%
  summarise(total_genes = sum(number_of_genes))
print(number_of_genes_per_chrom)
# for GWAS, use only features in "mRNA" and create a midpoint to find SNPs closest to the gene
seygenes <- seyall %>% filter(feature %in% "mRNA") %>% arrange(start,end) %>% mutate(mid = start + (end-start)/2) 
rm(swgff)
```

## GWAS

In progress. Adapting script from Stoffel et. al 2021: <https://github.com/mastoffel/sheep_ID/blob/master/6_alt_gwas_annual_survival_bothA_sep.R> We need to fit an inbreeding depression model for each SNP wihtin ROH. Then use the functional annotations if a few strong SNPs turn up. 

```{r gwas, eval = FALSE, echo = TRUE}

library(lme4)
library(tidyverse)
library(broom.mixed)
library(snpStats)
library(data.table)
library(furrr)

# for running on server, this allows to run an array job for splitting
# the GWAS up in parts
part_inp  <- commandArgs(trailingOnly=TRUE)
if (!(length(part_inp) == 0)) {
        part <- as.numeric(part_inp[[1]])
} else {
        # if no part selected, take first 1000
        part <- 1000
}


# GRM PCs from plink
pcs <- read_delim("data/ann_surv_pca.txt", " ", col_names = TRUE) %>% 
        mutate(id = as.character(id))

# roh data
file_path <- "data/roh.hom"
roh_lengths <- fread(file_path)

# plink name
sheep_plink_name <- "data/sheep_geno_imputed_oar_filt"
# read merged plink data
sheep_bed <- paste0(sheep_plink_name, ".bed")
sheep_bim <- paste0(sheep_plink_name, ".bim")
sheep_fam <- paste0(sheep_plink_name, ".fam")
full_sample <- read.plink(sheep_bed, sheep_bim, sheep_fam)

# make list with all parts
all_snps <- 1:nrow(full_sample$map)
all_parts <- split(all_snps, ceiling(seq_along(all_snps )/1000)) # every part runs 500 models
snp_indices <- all_parts[[part]]

# filter map data
snps_map_sub <- as_tibble(full_sample$map[snp_indices, ])
# additive genotypes
geno_sub <- as_tibble(as(full_sample$genotypes[, snps_map_sub$snp.name], Class = "numeric"),
                      rownames = "id")
# survival data
# survival data preprocessing
annual_survival <- fitness_data %>% 
        # filter na rows
        filter_at(vars(survival, froh_all, birth_year, sheep_year), ~ !is.na(.)) %>% 
        mutate(age_cent = age - mean(age, na.rm = TRUE),
               age_cent2 = age_cent^2,
               age_std = as.numeric(scale(age)),
               age_std2 = age_std^2,
               # times 10 to estimate a 10% percent increase
               froh_all10 = froh_all * 10,
               froh_all10_cent = froh_all10 - mean(froh_all10, na.rm = TRUE),
               lamb = ifelse(age == 0, 1, 0),
               lamb_cent = lamb - mean(lamb, na.rm = TRUE),
               lamb = as.factor(lamb)) %>% 
        as.data.frame() 

#roh_lengths <- as.data.table(roh_lengths)
# check whether snp is in ROH for a given individual

setkey(roh_lengths, IID)
roh_id_per_snp <- function(i) {
        position <- as.numeric(snps_map_sub[i, "position"])
        chromosome <- as.numeric(snps_map_sub[i, "chromosome"])
        # varname <- paste0("roh", i)
        #roh <- as.numeric((roh_lengths$POS1 <= position) & (roh_lengths$POS2 >= position) & (roh_lengths$CHR == chromosome))
        #roh_lengths$roh <- roh
        roh_lengths[, roh := as.numeric((CHR == chromosome) & (POS1 <= position) & (POS2 >= position))]
        #roh_lengths[, roh := fifelse((POS1 <= position)&(POS2 >= position)&(CHR == chromosome), 1, 0)]
        roh_id <- roh_lengths[,  .(roh = max(roh)), by = c("IID")]$roh
}

roh_ind <- map(1:nrow(snps_map_sub), roh_id_per_snp)
roh_df <- as.data.frame(do.call(cbind, roh_ind))
names(roh_df) <- paste0("roh_", snps_map_sub$snp.name)
roh_df$id <- as.character(unique(roh_lengths$IID))


# make some space
rm(full_sample)

# which chromosomes do the snps span?
chrs <- unique(snps_map_sub$chromosome)
froh_no_chr <- paste0("froh_no_chr", chrs)
# join additive and roh data to survival for gwas
annual_survival_gwas <- annual_survival %>% 
        #mutate_at(vars(starts_with("froh_no_chr")), scale) %>% 
        dplyr::select(id, survival, sex, twin, lamb, birth_year, sheep_year, mum_id, age_std, age_std2, {{ froh_no_chr }}) %>% 
        left_join(pcs, by = "id") %>% 
        left_join(geno_sub, by = "id") %>% 
        left_join(roh_df, by = "id") %>% 
        as_tibble()

snp_names <- snps_map_sub$snp.name
#snp_names <- top_snps %>% group_by(chromosome) %>% top_n(-2, p.value) %>% .$snp.name
for (i in snp_names) {
        # dummy coding
        annual_survival_gwas[[paste0("roh_0_", i)]] <- as.numeric((annual_survival_gwas[[i]] == 0) & (annual_survival_gwas[[paste0("roh_", i)]] == 1))
        annual_survival_gwas[[paste0("roh_2_", i)]] <- as.numeric((annual_survival_gwas[[i]] == 2) & (annual_survival_gwas[[paste0("roh_", i)]] == 1))
        annual_survival_gwas[[paste0("roh_", i)]] <- NULL
}

# time saver function for modeling
nlopt <- function(par, fn, lower, upper, control) {
        .nloptr <<- res <- nloptr(par, fn, lb = lower, ub = upper, 
                                  opts = list(algorithm = "NLOPT_LN_BOBYQA", print_level = 1,
                                              maxeval = 1000, xtol_abs = 1e-6, ftol_abs = 1e-6))
        list(par = res$solution,
             fval = res$objective,
             conv = if (res$status > 0) 0 else res$status,
             message = res$message
        )
}

# focal SNP, chromosome of focal snp, data
run_gwas <- function(snp, data) {
        # for mean froh without focal chr
        chr <- as.numeric(snps_map_sub[snps_map_sub$snp.name == snp, "chromosome"])
        froh_no_chr <- paste0("froh_no_chr", chr)
        
        formula_snp <- as.formula(paste0("survival ~ 1 + sex + twin + age_std + age_std2 + ", 
                                         froh_no_chr, " + ",
                                         "pc1 + pc2 + pc3 + pc4 + pc5 + pc6 + pc7 + ",
                                         #"pc1 + pc2 + pc3 + pc4 +",
                                         snp, "+ ", paste0("roh_0_", snp), "+",  paste0("roh_2_", snp), "+ (1|birth_year) + (1|sheep_year) + (1|id)"))
        #snp, "+ ", paste0("roh_", snp), " + (1|sheep_year) + (1|id)"))
        mod <- glmer(formula = formula_snp,
                     data = data, family = "binomial",
                     control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE))
        out <- broom.mixed::tidy(mod)
        out
}

safe_run_gwas <- purrr::safely(run_gwas)

# 

snps_sub <- snps_map_sub$snp.name
# split into pieces of 50 SNPs 
num_parts <- round(length(seq_along(snps_sub )) / 50)
snps_pieces <- split(snps_sub, cut(seq_along(snps_sub), num_parts, labels = FALSE))
roh_pieces_0 <- map(snps_pieces, function(x) paste0("roh_0_", x)) #### to change here
roh_pieces_2 <- map(snps_pieces, function(x) paste0("roh_2_", x)) 

annual_survival_gwas_pieces <- 
        pmap(list(snps_pieces, roh_pieces_0, roh_pieces_2), function(snps_piece, roh_piece_0, roh_piece_2) {
                annual_survival_gwas %>% dplyr::select(id:pc7, one_of(c(snps_piece, roh_piece_0, roh_piece_2 )))   
        })

# clean up
rm(annual_survival, annual_survival_gwas, fitness_data, geno_sub, 
   roh_lengths, roh_pieces_0, roh_pieces_2, sheep_ped, roh_df)

# set up plan
plan(multiprocess, workers = 6)

# increase maxSize
options(future.globals.maxSize = 3000 * 1024^2)

all_out <- future_map2(snps_pieces, annual_survival_gwas_pieces, function(snps, data) {
        out <- purrr::map(snps, safe_run_gwas, data)
})

all_out_simple <- purrr::flatten(all_out)
saveRDS(all_out_simple, file = paste0("output/GWAS_roh_sep_part", "_", part, ".rds"))


### testing
# all_out <- future_map2(snps_pieces[1], annual_survival_gwas_pieces[1], function(snps, data) {
#         out <- purrr::map(snps[1:3], safe_run_gwas, data)
# })
```


## Demographic history

Demographic history inference using GONE. 11420278 SNPs and 1657 individuals initially from genotyping rate \> 0.99 and individuals removed by genotyping rate \> 0.96. GONE is only good for the past 100 generations.

```{r demographic_history, eval = TRUE, echo = TRUE, tidy=FALSE}
#Generation time calculation
##add parent birth date from "BirthDate" to "Offspring"
BirthDate$Parent<-BirthDate$BirdID
OffspringParentBirthDate<-merge(Offspring, BirthDate, by= "Parent", all =TRUE)
OffspringParentBirthDate$ParentBirthDate<-OffspringParentBirthDate$BirthDate.y

##calculate mean birth date difference
OffspringParentBirthDate$BirthDateDifference<-OffspringParentBirthDate$BirthDate.x-OffspringParentBirthDate$ParentBirthDate
BirthDateDifference<-(!is.na (OffspringParentBirthDate$BirthDateDifference))
BirthDateDifference <- subset(OffspringParentBirthDate$BirthDateDifference, !is.na(OffspringParentBirthDate$BirthDateDifference))

mean(OffspringParentBirthDate$BirthDateDifference, na.rm = TRUE)
1764/365 ##4.8 generation time

#Deduplicate samples for GONE as it doesn't handle duplicates and they will need renaming
DeduplicatedforGONE<-data.frame(rep("0",length(Seychelles_warbler_traits$Filepath)),Seychelles_warbler_traits$Filepath)
write.table(DeduplicatedforGONE, file = "DeduplicatedforGONE.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Load output from GONE
GONE<-read.table("outfileLD_Ne_estimates1recomb20000snps",header=F, fill=TRUE) #Recomb 1, 20,000SNPs looks good
GONE <- GONE[-c(1, 2), ]
rownames(GONE) <- NULL
colnames(GONE) <- c("Generation", "Ne")
GONE$YearsAgo<-as.numeric(GONE$Generation)*4.8
GONE$Ne<-as.numeric(GONE$Ne)
GONE$Generation<-as.numeric(GONE$Generation)
GONE<-subset(GONE, GONE$Generation<100)

#Plot. NB I will need to iterate this to get confidence intervals
ggplot(GONE, aes(x = Generation, y = Ne)) +
  geom_point(color = "blue") +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 200, by = 20)) +  # Set the X-axis range and breaks
  labs(x = "Generation", y = "Ne", title = "Plot of Generations vs Ne") +
  theme_minimal()

```
